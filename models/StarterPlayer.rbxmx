<roblox version="4">
  <Item class="StarterPlayer" referent="0">
    <Properties>
      <string name="Name">StarterPlayer</string>
      <bool name="AllowCustomAnimations">true</bool>
      <BinaryString name="AttributesSerialize"></BinaryString>
      <bool name="AutoJumpEnabled">true</bool>
      <token name="AvatarJointUpgrade_SerializedRollout">0</token>
      <float name="CameraMaxZoomDistance">128</float>
      <float name="CameraMinZoomDistance">0.5</float>
      <token name="CameraMode">0</token>
      <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
      <float name="CharacterJumpHeight">7.2</float>
      <float name="CharacterJumpPower">50</float>
      <float name="CharacterMaxSlopeAngle">89</float>
      <bool name="CharacterUseJumpPower">false</bool>
      <float name="CharacterWalkSpeed">16</float>
      <bool name="ClassicDeath">true</bool>
      <token name="DevCameraOcclusionMode">0</token>
      <token name="DevComputerCameraMovementMode">0</token>
      <token name="DevComputerMovementMode">0</token>
      <token name="DevTouchCameraMovementMode">0</token>
      <token name="DevTouchMovementMode">0</token>
      <token name="EnableDynamicHeads">0</token>
      <bool name="EnableMouseLockOption">false</bool>
      <int64 name="GameSettingsAssetIDFace">0</int64>
      <int64 name="GameSettingsAssetIDHead">0</int64>
      <int64 name="GameSettingsAssetIDLeftArm">0</int64>
      <int64 name="GameSettingsAssetIDLeftLeg">0</int64>
      <int64 name="GameSettingsAssetIDPants">0</int64>
      <int64 name="GameSettingsAssetIDRightArm">0</int64>
      <int64 name="GameSettingsAssetIDRightLeg">0</int64>
      <int64 name="GameSettingsAssetIDShirt">0</int64>
      <int64 name="GameSettingsAssetIDTeeShirt">0</int64>
      <int64 name="GameSettingsAssetIDTorso">0</int64>
      <token name="GameSettingsAvatar">1</token>
      <token name="GameSettingsR15Collision">0</token>
      <NumberRange name="GameSettingsScaleRangeBodyType">0 1 </NumberRange>
      <NumberRange name="GameSettingsScaleRangeHead">0.95 1 </NumberRange>
      <NumberRange name="GameSettingsScaleRangeHeight">0.9 1.05 </NumberRange>
      <NumberRange name="GameSettingsScaleRangeProportion">0 1 </NumberRange>
      <NumberRange name="GameSettingsScaleRangeWidth">0.7 1 </NumberRange>
      <float name="HealthDisplayDistance">100</float>
      <bool name="LoadCharacterAppearance">true</bool>
      <token name="LoadCharacterLayeredClothing">0</token>
      <token name="LuaCharacterController">0</token>
      <float name="NameDisplayDistance">100</float>
      <bool name="RagdollDeath">true</bool>
      <bool name="DefinesCapabilities">false</bool>
      <int64 name="SourceAssetId">-1</int64>
      <BinaryString name="Tags"></BinaryString>
      <bool name="UserEmotesEnabled">true</bool>
    </Properties>
    <Item class="StarterPlayerScripts" referent="1">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
        <bool name="DefinesCapabilities">false</bool>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
      <Item class="Folder" referent="2">
        <Properties>
          <string name="Name">TS</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
          <bool name="DefinesCapabilities">false</bool>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
        <Item class="Folder" referent="3">
          <Properties>
            <string name="Name">controllers</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
            <bool name="DefinesCapabilities">false</bool>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="4">
            <Properties>
              <string name="Name">InventoryController</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
              <ContentId name="LinkedSource">
                <null>
                </null>
              </ContentId>
              <bool name="DefinesCapabilities">false</bool>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Reflect = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Reflect
local Controller = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Controller
local Players = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Players
local Signal = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "lemon-signal", "src").default
local player = Players.LocalPlayer
local InventoryController
do
	InventoryController = setmetatable({}, {
		__tostring = function()
			return "InventoryController"
		end,
	})
	InventoryController.__index = InventoryController
	function InventoryController.new(...)
		local self = setmetatable({}, InventoryController)
		return self:constructor(...) or self
	end
	function InventoryController:constructor(stateProvider)
		self.stateProvider = stateProvider
		self.playerStoppedHoldingTower = Signal.new()
	end
	function InventoryController:onStart()
	end
	do
		-- (Flamework) InventoryController metadata
		Reflect.defineMetadata(InventoryController, "identifier", "client/controllers/InventoryController@InventoryController")
		Reflect.defineMetadata(InventoryController, "flamework:parameters", { "client/controllers/ClientStateProvider@ClientStateProvider" })
		Reflect.defineMetadata(InventoryController, "flamework:implements", { "$:flamework@OnStart" })
	end
end
-- (Flamework) InventoryController decorators
Reflect.decorate(InventoryController, "$:flamework@Controller", Controller, { {} })
return {
	InventoryController = InventoryController,
}
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="5">
            <Properties>
              <string name="Name">TrackController</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
              <ContentId name="LinkedSource">
                <null>
                </null>
              </ContentId>
              <bool name="DefinesCapabilities">false</bool>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Reflect = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Reflect
local Controller = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Controller
local CollectionService = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").CollectionService
local TAG_TRACK = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "constants").TAG_TRACK
local TrackController
do
	TrackController = setmetatable({}, {
		__tostring = function()
			return "TrackController"
		end,
	})
	TrackController.__index = TrackController
	function TrackController.new(...)
		local self = setmetatable({}, TrackController)
		return self:constructor(...) or self
	end
	function TrackController:constructor()
		self.waypoints = {}
		self.trackLength = -1
		self.trackInstance = nil
	end
	function TrackController:onInit()
		--[[
			*
			         * Change to wait for all waypoints to load in
			         
		]]
		task.wait(1)
	end
	function TrackController:onStart()
		local trackInstance = CollectionService:GetTagged(TAG_TRACK)[1]
		local _exp = trackInstance.waypoints:GetChildren()
		table.sort(_exp, function(a, b)
			return tonumber(a.Name) < tonumber(b.Name)
		end)
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#_exp)
		local _callback = function(i)
			return i.Position
		end
		for _k, _v in _exp do
			_newValue[_k] = _callback(_v, _k - 1, _exp)
		end
		-- ▲ ReadonlyArray.map ▲
		self.waypoints = _newValue
		local total = 0
		for i = 0, #self.waypoints - 2 do
			local _exp_1 = self.waypoints[i + 2]
			local _arg0 = self.waypoints[i + 1]
			total += (_exp_1 - _arg0).Magnitude
		end
		self.trackLength = total
		self.trackInstance = trackInstance
	end
	function TrackController:getWaypoints()
		return self.waypoints
	end
	function TrackController:getTrack()
		return self.trackInstance
	end
	function TrackController:getTrackLength()
		return self.trackLength
	end
	function TrackController:getPositionOnTrack(speed, t)
		local d = speed * t
		local distAccum = 0
		for i = 0, #self.waypoints - 2 do
			local a = self.waypoints[i + 1]
			local b = self.waypoints[i + 2]
			local L = (b - a).Magnitude
			if d <= distAccum + L then
				local segDist = d - distAccum
				local alpha = segDist / L
				return a:Lerp(b, alpha)
			end
			distAccum += L
		end
		-- Clamp to the last waypoint if we've passed the end
		return self.waypoints[#self.waypoints]
	end
	do
		-- (Flamework) TrackController metadata
		Reflect.defineMetadata(TrackController, "identifier", "client/controllers/TrackController@TrackController")
		Reflect.defineMetadata(TrackController, "flamework:implements", { "$:flamework@OnInit", "$:flamework@OnStart" })
	end
end
-- (Flamework) TrackController decorators
Reflect.decorate(TrackController, "$:flamework@Controller", Controller, { {} })
return {
	TrackController = TrackController,
}
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="6">
            <Properties>
              <string name="Name">EnemyController</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
              <ContentId name="LinkedSource">
                <null>
                </null>
              </ContentId>
              <bool name="DefinesCapabilities">false</bool>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Reflect = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Reflect
local Controller = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Controller
local Enemy_C = TS.import(script, script.Parent.Parent, "classes", "Enemy_C").Enemy_C
local Events = TS.import(script, script.Parent.Parent, "networking").Events
local EnemyController
do
	EnemyController = setmetatable({}, {
		__tostring = function()
			return "EnemyController"
		end,
	})
	EnemyController.__index = EnemyController
	function EnemyController.new(...)
		local self = setmetatable({}, EnemyController)
		return self:constructor(...) or self
	end
	function EnemyController:constructor()
		self.enemies = {}
	end
	function EnemyController:onStart()
		Events.enemySpawned:connect(function(i, e)
			return self:onEnemySpawned(i, e)
		end)
		Events.enemyDeleted:connect(function(i)
			return self:onEnemyDeleted(i)
		end)
		Events.updateEnemyHealth:connect(function(i, v)
			return self:onEnemyHealthUpdated(i, v)
		end)
	end
	function EnemyController:getEnemies()
		local _array = {}
		local _length = #_array
		for _k, _v in self.enemies do
			_length += 1
			_array[_length] = { _k, _v }
		end
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#_array)
		local _callback = function(v)
			return v[2]
		end
		for _k, _v in _array do
			_newValue[_k] = _callback(_v, _k - 1, _array)
		end
		-- ▲ ReadonlyArray.map ▲
		return _newValue
	end
	function EnemyController:onEnemySpawned(id, enemy)
		local newEnemy = Enemy_C.new(id, enemy)
		local _enemies = self.enemies
		local _id = id
		_enemies[_id] = newEnemy
	end
	function EnemyController:onEnemyDeleted(id)
		local _enemies = self.enemies
		local _id = id
		_enemies[_id]:destroy()
		local _enemies_1 = self.enemies
		local _id_1 = id
		_enemies_1[_id_1] = nil
	end
	function EnemyController:onEnemyHealthUpdated(id, value)
		local _enemies = self.enemies
		local _id = id
		_enemies[_id].health = value
	end
	do
		-- (Flamework) EnemyController metadata
		Reflect.defineMetadata(EnemyController, "identifier", "client/controllers/EnemyController@EnemyController")
		Reflect.defineMetadata(EnemyController, "flamework:implements", { "$:flamework@OnStart" })
	end
end
-- (Flamework) EnemyController decorators
Reflect.decorate(EnemyController, "$:flamework@Controller", Controller, { {} })
return {
	EnemyController = EnemyController,
}
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="7">
            <Properties>
              <string name="Name">TooltipController</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
              <ContentId name="LinkedSource">
                <null>
                </null>
              </ContentId>
              <bool name="DefinesCapabilities">false</bool>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Reflect = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Reflect
local Controller = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Controller
local _services = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services")
local CollectionService = _services.CollectionService
local Players = _services.Players
local RunService = _services.RunService
local UserInputService = _services.UserInputService
local Workspace = _services.Workspace
local _constants = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "constants")
local ATTR_OWNER = _constants.ATTR_OWNER
local TOOLTIPS_ENABLED = _constants.TOOLTIPS_ENABLED
local atom = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "charm").atom
local createRoot = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "react-roblox").createRoot
local React = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "react")
local TAG_TOWER = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "constants").TAG_TOWER
local findFirstAncestorWithTag = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "util", "findFirstAncestorWithTag").findFirstAncestorWithTag
local TooltipUI = TS.import(script, script.Parent.Parent, "ui", "Tooltip").TooltipUI
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local camera = Workspace.CurrentCamera
local TooltipController
do
	TooltipController = setmetatable({}, {
		__tostring = function()
			return "TooltipController"
		end,
	})
	TooltipController.__index = TooltipController
	function TooltipController.new(...)
		local self = setmetatable({}, TooltipController)
		return self:constructor(...) or self
	end
	function TooltipController:constructor(stateProvider)
		self.stateProvider = stateProvider
		self.isPlacing = false
	end
	function TooltipController:onStart()
		if TOOLTIPS_ENABLED then
			self:enableTowerTooltips()
		end
	end
	function TooltipController:enableTowerTooltips()
		local visible = atom(true)
		local mousePos = atom(Vector2.new(0, 0))
		local hoveredTower = atom("None")
		local towerOwnerAtom = atom()
		local root = createRoot(playerGui)
		root:render(React.createElement(TooltipUI, {
			hoveredTower = hoveredTower,
			visibleAtom = visible,
			mousePosAtom = mousePos,
			ownerAtom = towerOwnerAtom,
		}))
		RunService.RenderStepped:Connect(function(dt)
			if self.isPlacing then
				return nil
			end
			local _binding = UserInputService:GetMouseLocation()
			local X = _binding.X
			local Y = _binding.Y
			local _binding_1 = camera:ViewportPointToRay(X, Y)
			local Origin = _binding_1.Origin
			local Direction = _binding_1.Direction
			local rayParams = RaycastParams.new()
			rayParams.FilterType = Enum.RaycastFilterType.Include
			rayParams.FilterDescendantsInstances = CollectionService:GetTagged(TAG_TOWER)
			local rayResult = Workspace:Raycast(Origin, Direction * 1000, rayParams)
			if rayResult then
				local tower = findFirstAncestorWithTag(rayResult.Instance, TAG_TOWER)
				visible(true)
				mousePos(Vector2.new(X, Y))
				local _result = tower
				if _result ~= nil then
					_result = _result:GetAttribute(ATTR_OWNER)
				end
				towerOwnerAtom(_result)
				hoveredTower(if tower then (tower.Name) else "None")
			else
				visible(false)
			end
		end)
	end
	do
		-- (Flamework) TooltipController metadata
		Reflect.defineMetadata(TooltipController, "identifier", "client/controllers/TooltipController@TooltipController")
		Reflect.defineMetadata(TooltipController, "flamework:parameters", { "client/controllers/ClientStateProvider@ClientStateProvider" })
		Reflect.defineMetadata(TooltipController, "flamework:implements", { "$:flamework@OnStart" })
	end
end
-- (Flamework) TooltipController decorators
Reflect.decorate(TooltipController, "$:flamework@Controller", Controller, { {} })
return {
	TooltipController = TooltipController,
}
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="8">
            <Properties>
              <string name="Name">ClientStateProvider</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
              <ContentId name="LinkedSource">
                <null>
                </null>
              </ContentId>
              <bool name="DefinesCapabilities">false</bool>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Reflect = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Reflect
local _core = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out")
local Controller = _core.Controller
local Modding = _core.Modding
local atom = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "charm").atom
local Events = TS.import(script, script.Parent.Parent, "networking").Events
local t = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "t", "lib", "ts").t
local SYNC_KEYS = Modding.inspect({ "money", "exp", "rebirth", "inventory" })
local tSyncKey = t.literal("money", "exp", "rebirth", "inventory")
local ClientStateProvider
do
	ClientStateProvider = setmetatable({}, {
		__tostring = function()
			return "ClientStateProvider"
		end,
	})
	ClientStateProvider.__index = ClientStateProvider
	function ClientStateProvider.new(...)
		local self = setmetatable({}, ClientStateProvider)
		return self:constructor(...) or self
	end
	function ClientStateProvider:constructor()
		self.selectedTower = atom("None")
		self.playerState = {}
		for _, key in SYNC_KEYS do
			(self.playerState)[key] = atom(nil)
		end
	end
	function ClientStateProvider:onInit()
		Events.playerStateChanged:connect(function(key, state, prev)
			if not tSyncKey(key) then
				return nil
			end
			self.playerState[key](state)
		end)
	end
	do
		-- (Flamework) ClientStateProvider metadata
		Reflect.defineMetadata(ClientStateProvider, "identifier", "client/controllers/ClientStateProvider@ClientStateProvider")
		Reflect.defineMetadata(ClientStateProvider, "flamework:implements", { "$:flamework@OnInit" })
	end
end
-- (Flamework) ClientStateProvider decorators
Reflect.decorate(ClientStateProvider, "$:flamework@Controller", Controller, { {} })
return {
	ClientStateProvider = ClientStateProvider,
}
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="9">
            <Properties>
              <string name="Name">TowerPlacementController</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
              <ContentId name="LinkedSource">
                <null>
                </null>
              </ContentId>
              <bool name="DefinesCapabilities">false</bool>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Reflect = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Reflect
local Controller = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Controller
local _services = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services")
local Players = _services.Players
local ReplicatedStorage = _services.ReplicatedStorage
local RunService = _services.RunService
local UserInputService = _services.UserInputService
local Workspace = _services.Workspace
local Functions = TS.import(script, script.Parent.Parent, "networking").Functions
local TowerConfig = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "config", "TowerConfig").TowerConfig
local t = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "t", "lib", "ts").t
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local camera = Workspace.CurrentCamera
local towerFolder = ReplicatedStorage.Assets.Towers
local tTowerName = t.literal("None", "Barbarian", "Archer", "Cannon", "Sharpshooter")
--[[
	*
	 * Handles tower placement (preview, input, placement logic, etc.)
	 
]]
local makePartPreview
local TowerPlacementController
do
	TowerPlacementController = setmetatable({}, {
		__tostring = function()
			return "TowerPlacementController"
		end,
	})
	TowerPlacementController.__index = TowerPlacementController
	function TowerPlacementController.new(...)
		local self = setmetatable({}, TowerPlacementController)
		return self:constructor(...) or self
	end
	function TowerPlacementController:constructor(trackController, stateProvider)
		self.trackController = trackController
		self.stateProvider = stateProvider
		self.isPlacing = false
		self.rangePreview = Instance.new("Part")
		self.selectedTower = self.stateProvider.selectedTower
	end
	function TowerPlacementController:onStart()
		-- Setup range preview part
		self.rangePreview.Anchored = true
		self.rangePreview.CanCollide = false
		self.rangePreview.Transparency = 1
		self.rangePreview.Material = Enum.Material.Neon
		self.rangePreview.Color = Color3.new(1, 1, 1)
		self.rangePreview.Parent = Workspace.Preview
		self.rangePreview.Shape = Enum.PartType.Cylinder
		self.rangePreview.Orientation = Vector3.new(0, 90, 90)
		-- Equipping tower tools (to place)
		player.CharacterAdded:Connect(function(char)
			local human = char:WaitForChild("Humanoid")
			char.ChildAdded:Connect(function(child)
				if not (child:IsA("Tool") and tTowerName(child.Name)) then
					return nil
				end
				self:startPlacingTower(child)
				local c
				c = char.AncestryChanged:Connect(function(_, p)
					if p ~= char then
						self:stopPlacingTower()
						c:Disconnect()
					end
				end)
			end)
			human.Died:Connect(function()
				return self:stopPlacingTower()
			end)
		end)
		-- Confirm placement
		UserInputService.InputBegan:Connect(function(input, gpe)
			if gpe then
				return nil
			end
			if input.UserInputType == Enum.UserInputType.MouseButton1 and self.isPlacing then
				self:confirmTowerPlacement()
			end
		end)
	end
	function TowerPlacementController:stopPlacingTower()
		if not self.isPlacing then
			return nil
		end
		self.isPlacing = false
		self.selectedTower("None")
		local _result = self.mouseStepped
		if _result ~= nil then
			_result:Disconnect()
		end
		self.rangePreview.Parent = Workspace.Preview
		self.rangePreview.Transparency = 1
		local _result_1 = self.previewModel
		if _result_1 ~= nil then
			_result_1:Destroy()
		end
	end
	function TowerPlacementController:startPlacingTower(tool)
		local tower = tool.Name
		if self.isPlacing then
			self:stopPlacingTower()
		end
		if tower == "None" then
			return nil
		end
		self.selectedTower(tower)
		self.isPlacing = true
		local preview = towerFolder[tower]:Clone()
		self.previewModel = preview
		preview.Parent = Workspace.Preview
		local _exp = preview:GetDescendants()
		-- ▼ ReadonlyArray.filter ▼
		local _newValue = {}
		local _callback = function(i)
			return i:IsA("BasePart")
		end
		local _length = 0
		for _k, _v in _exp do
			if _callback(_v, _k - 1, _exp) == true then
				_length += 1
				_newValue[_length] = _v
			end
		end
		-- ▲ ReadonlyArray.filter ▲
		for _k, _v in _newValue do
			makePartPreview(_v, _k - 1, _newValue)
		end
		local previewHitbox = preview.hitbox
		previewHitbox.Transparency = 0.9
		local range = TowerConfig[tower].range
		self.rangePreview:PivotTo(previewHitbox.CFrame)
		self.rangePreview.Size = Vector3.new(0.1, range * 2, range * 2)
		self.rangePreview.Transparency = 0.9
		self.rangePreview.Parent = preview
		self.mouseStepped = RunService.RenderStepped:Connect(function(dt)
			local pos = self:mouseToTowerPos(tower)
			if pos then
				if self:canPlace() then
					previewHitbox.Color = Color3.new(0, 1, 0)
				else
					previewHitbox.Color = Color3.new(1, 0, 0)
				end
				preview:MoveTo(pos)
			end
		end)
		tool.AncestryChanged:Connect(function(parent)
			if parent ~= player.Character then
				self:stopPlacingTower()
			end
		end)
	end
	function TowerPlacementController:canPlace()
		local mousePos = self:mouseToTowerPos(self.selectedTower())
		return mousePos ~= nil and self:posNotOnTrackOrTower(mousePos) and self.isPlacing
	end
	function TowerPlacementController:posNotOnTrackOrTower(pos)
		return self:posNotOnTower(pos) and self:posNotOnTrack(pos)
	end
	function TowerPlacementController:posNotOnTrack(pos)
		local path = self.trackController:getTrack().path:GetChildren()
		local tower = self.selectedTower()
		local radius = towerFolder[tower].hitbox.Size.Y / 2
		for _, part in path do
			local halfSizeX = part.Size.X / 2
			local halfSizeZ = part.Size.Z / 2
			local minX = part.Position.X - halfSizeX
			local maxX = part.Position.X + halfSizeX
			local minZ = part.Position.Z - halfSizeZ
			local maxZ = part.Position.Z + halfSizeZ
			local closestX = math.clamp(pos.X, minX, maxX)
			local closestZ = math.clamp(pos.Z, minZ, maxZ)
			local dx = pos.X - closestX
			local dz = pos.Z - closestZ
			if dx * dx + dz * dz < radius * radius then
				return false
			end
		end
		return true
	end
	function TowerPlacementController:posNotOnTower(pos)
		local tower = self.selectedTower()
		local radius = towerFolder[tower].hitbox.Size.Y / 2
		local _exp = Workspace.Towers:GetChildren()
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#_exp)
		local _callback = function(t)
			return t:FindFirstChild("hitbox")
		end
		for _k, _v in _exp do
			_newValue[_k] = _callback(_v, _k - 1, _exp)
		end
		-- ▲ ReadonlyArray.map ▲
		-- ▼ ReadonlyArray.filter ▼
		local _newValue_1 = {}
		local _callback_1 = function(t)
			return t:IsA("BasePart")
		end
		local _length = 0
		for _k, _v in _newValue do
			if _callback_1(_v, _k - 1, _newValue) == true then
				_length += 1
				_newValue_1[_length] = _v
			end
		end
		-- ▲ ReadonlyArray.filter ▲
		local towerHitboxes = _newValue_1
		local px = pos.X
		local pz = pos.Z
		for _, hitbox in towerHitboxes do
			-- defensive: ensure we have a valid BasePart
			if not hitbox or not hitbox:IsA("BasePart") then
				continue
			end
			local dx = px - hitbox.Position.X
			local dz = pz - hitbox.Position.Z
			if dx * dx + dz * dz < radius * radius then
				return false
			end
		end
		return true
	end
	function TowerPlacementController:confirmTowerPlacement()
		local selectedTower = self.selectedTower()
		local _isPlacing = self.isPlacing
		local _arg1 = `{"[src/client/controllers/TowerPlacementController.ts:218]"} {"this.isPlacing"}: Assertion failed!`
		assert(_isPlacing, _arg1)
		local _arg0 = selectedTower ~= "None"
		local _arg1_1 = `{"[src/client/controllers/TowerPlacementController.ts:219]"} {'selectedTower !== \"None\"'}: Assertion failed!`
		assert(_arg0, _arg1_1)
		local placementPos = self:mouseToTowerPos(selectedTower)
		local _arg1_2 = `{"[src/client/controllers/TowerPlacementController.ts:221]"} {"placementPos"}: {`this.mouseToTowerPos({self.selectedTower}) returned undefined`}`
		assert(placementPos, _arg1_2)
		local _clone = self.previewModel
		if _clone ~= nil then
			_clone = _clone:Clone()
		end
		local clone = _clone
		Functions.requestPlaceTower:invoke(placementPos, selectedTower):andThen(function(wasPlaced)
			if wasPlaced then
				local _result = clone
				if _result ~= nil then
					_result:Destroy()
				end
			else
				-- Failed, make clone red then destroy or seomthing
				local _result = clone
				if _result ~= nil then
					_result:Destroy()
				end
			end
		end)
	end
	function TowerPlacementController:mouseToTowerPos(tower)
		local _binding = UserInputService:GetMouseLocation()
		local X = _binding.X
		local Y = _binding.Y
		local _binding_1 = camera:ViewportPointToRay(X, Y)
		local Origin = _binding_1.Origin
		local Direction = _binding_1.Direction
		local rayParams = RaycastParams.new()
		rayParams.FilterType = Enum.RaycastFilterType.Exclude
		rayParams.FilterDescendantsInstances = { Workspace.Preview, Workspace.Live, Workspace.Towers }
		local rayResult = Workspace:Raycast(Origin, Direction * 1000, rayParams)
		if rayResult then
			local _binding_2 = rayResult.Position
			local X = _binding_2.X
			local Z = _binding_2.Z
			local worldSize = towerFolder[tower]:GetExtentsSize()
			local Y = rayResult.Position.Y + worldSize.Y / 2
			return Vector3.new(X, Y, Z)
		end
	end
	do
		-- (Flamework) TowerPlacementController metadata
		Reflect.defineMetadata(TowerPlacementController, "identifier", "client/controllers/TowerPlacementController@TowerPlacementController")
		Reflect.defineMetadata(TowerPlacementController, "flamework:parameters", { "client/controllers/TrackController@TrackController", "client/controllers/ClientStateProvider@ClientStateProvider" })
		Reflect.defineMetadata(TowerPlacementController, "flamework:implements", { "$:flamework@OnStart" })
	end
end
-- (Flamework) TowerPlacementController decorators
Reflect.decorate(TowerPlacementController, "$:flamework@Controller", Controller, { {} })
function makePartPreview(part)
	if part.Name == "hitbox" then
		return nil
	end
	part.Transparency = 0.5
	part.CanCollide = false
	part.CanQuery = false
end
return {
	TowerPlacementController = TowerPlacementController,
}
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="10">
            <Properties>
              <string name="Name">TowerRenderer</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
              <ContentId name="LinkedSource">
                <null>
                </null>
              </ContentId>
              <bool name="DefinesCapabilities">false</bool>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Reflect = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Reflect
local Controller = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Controller
local Events = TS.import(script, script.Parent.Parent, "networking").Events
local Tower_C = TS.import(script, script.Parent.Parent, "classes", "Tower_C").Tower_C
--[[
	*
	 * Syncs tower's data and renders tower instances
	 
]]
local TowerRenderer
do
	TowerRenderer = setmetatable({}, {
		__tostring = function()
			return "TowerRenderer"
		end,
	})
	TowerRenderer.__index = TowerRenderer
	function TowerRenderer.new(...)
		local self = setmetatable({}, TowerRenderer)
		return self:constructor(...) or self
	end
	function TowerRenderer:constructor(enemyController, stateProvider)
		self.enemyController = enemyController
		self.stateProvider = stateProvider
		self.towers = {}
	end
	function TowerRenderer:onStart()
		Events.towerPlaced:connect(function(i, p, t, o)
			return self:onTowerPlaced(i, p, t, o)
		end)
		Events.towerDeleted:connect(function(i)
			return self:onTowerDeleted(i)
		end)
		Events.towerAttackedEnemy:connect(function(t, e)
			return self:onTowerAttackedEnemy(t, e)
		end)
		Events.setTowerTargetMode:connect(function(i, t)
			return self:onTowerTargetModeChanged(i, t)
		end)
	end
	function TowerRenderer:onTowerTargetModeChanged(id, mode)
		local _towers = self.towers
		local _id = id
		local tower = _towers[_id]
		tower.targetMode = mode
	end
	function TowerRenderer:onTowerPlaced(id, pos, tower, owner)
		local newTower = Tower_C.new(id, pos, tower, self.enemyController, owner)
		local _towers = self.towers
		local _id = id
		_towers[_id] = newTower
	end
	function TowerRenderer:onTowerDeleted(id)
		local _towers = self.towers
		local _id = id
		_towers[_id]:destroy()
		local _towers_1 = self.towers
		local _id_1 = id
		_towers_1[_id_1] = nil
	end
	function TowerRenderer:onTowerAttackedEnemy(towerId, enemyId)
		local _towers = self.towers
		local _towerId = towerId
		local tower = _towers[_towerId]
		if tower then
			tower.damageDealt += tower.info.damage
		end
	end
	do
		-- (Flamework) TowerRenderer metadata
		Reflect.defineMetadata(TowerRenderer, "identifier", "client/controllers/TowerRenderer@TowerRenderer")
		Reflect.defineMetadata(TowerRenderer, "flamework:parameters", { "client/controllers/EnemyController@EnemyController", "client/controllers/ClientStateProvider@ClientStateProvider" })
		Reflect.defineMetadata(TowerRenderer, "flamework:implements", { "$:flamework@OnStart" })
	end
end
-- (Flamework) TowerRenderer decorators
Reflect.decorate(TowerRenderer, "$:flamework@Controller", Controller, { {} })
return {
	TowerRenderer = TowerRenderer,
}
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
        </Item>
        <Item class="LocalScript" referent="11">
          <Properties>
            <string name="Name">main</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
            <bool name="Disabled">false</bool>
            <ContentId name="LinkedSource">
              <null>
              </null>
            </ContentId>
            <token name="RunContext">0</token>
            <bool name="DefinesCapabilities">false</bool>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Flamework = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Flamework
Flamework._addPaths({ { "StarterPlayer", "StarterPlayerScripts", "TS", "classes" } })
Flamework._addPaths({ { "StarterPlayer", "StarterPlayerScripts", "TS", "controllers" } })
Flamework._addPaths({ { "StarterPlayer", "StarterPlayerScripts", "TS", "components" } })
Flamework.ignite()
print("[src/client/main.client.ts:9]", "Flamework client ignited!")
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="12">
          <Properties>
            <string name="Name">networking</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
            <ContentId name="LinkedSource">
              <null>
              </null>
            </ContentId>
            <bool name="DefinesCapabilities">false</bool>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local t = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out", "prelude").t
local _networking = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "networking")
local GlobalEvents = _networking.GlobalEvents
local GlobalFunctions = _networking.GlobalFunctions
local Events = GlobalEvents:createClient({}, {
	incomingIds = { "setEquipBar", "updateEquipBar", "playerStateChanged", "enemySpawned", "enemyDeleted", "updateEnemyHealth", "syncEnemies", "towerPlaced", "towerDeleted", "setTowerTargetMode", "towerAttackedEnemy", "setUnlockedInventory", "addToUnlockedInventory", "removeFromUnlockedInventory" },
	incoming = {
		setEquipBar = { { t.array(t.literalList({ "None", "Barbarian", "Archer", "Cannon", "Sharpshooter" })) }, nil },
		updateEquipBar = { { t.number, t.literalList({ "None", "Barbarian", "Archer", "Cannon", "Sharpshooter" }) }, nil },
		playerStateChanged = { { t.string, t.union(t.any, t.none), t.union(t.any, t.none) }, nil },
		enemySpawned = { { t.number, t.literalList({ "Skeleton", "Armored_Skeleton", "Goblin" }) }, nil },
		enemyDeleted = { { t.number }, nil },
		updateEnemyHealth = { { t.number, t.number }, nil },
		syncEnemies = { { t.array(t.interface({
			id = t.number,
			pos = t.Vector3,
			elapsed = t.number,
			health = t.number,
		})) }, nil },
		towerPlaced = { { t.number, t.Vector3, t.literalList({ "None", "Barbarian", "Archer", "Cannon", "Sharpshooter" }), t.instanceIsA("Player") }, nil },
		towerDeleted = { { t.number }, nil },
		setTowerTargetMode = { { t.number, t.literalList({ "First", "Last", "Closest" }) }, nil },
		towerAttackedEnemy = { { t.number, t.number }, nil },
		setUnlockedInventory = { { t.array(t.literalList({ "None", "Barbarian", "Archer", "Cannon", "Sharpshooter" })) }, nil },
		addToUnlockedInventory = { { t.literalList({ "None", "Barbarian", "Archer", "Cannon", "Sharpshooter" }) }, nil },
		removeFromUnlockedInventory = { { t.literalList({ "None", "Barbarian", "Archer", "Cannon", "Sharpshooter" }) }, nil },
	},
	incomingUnreliable = {},
	outgoingIds = { "setEquipBar", "updateEquipBar" },
	outgoingUnreliable = {},
	namespaceIds = {},
	namespaces = {},
})
local Functions = GlobalFunctions:createClient({}, {
	incomingIds = {},
	incoming = {},
	outgoingIds = { "requestPlaceTower", "requestStartGame" },
	outgoing = {
		requestPlaceTower = t.boolean,
		requestStartGame = t.boolean,
	},
	namespaceIds = {},
	namespaces = {},
})
return {
	Events = Events,
	Functions = Functions,
}
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="LocalScript" referent="13">
          <Properties>
            <string name="Name">setCore</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
            <bool name="Disabled">false</bool>
            <ContentId name="LinkedSource">
              <null>
              </null>
            </ContentId>
            <token name="RunContext">0</token>
            <bool name="DefinesCapabilities">false</bool>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="Folder" referent="14">
          <Properties>
            <string name="Name">components</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
            <bool name="DefinesCapabilities">false</bool>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
        <Item class="Folder" referent="15">
          <Properties>
            <string name="Name">classes</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
            <bool name="DefinesCapabilities">false</bool>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="16">
            <Properties>
              <string name="Name">Enemy_C</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
              <ContentId name="LinkedSource">
                <null>
                </null>
              </ContentId>
              <bool name="DefinesCapabilities">false</bool>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Flamework = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Flamework
local EnemyConfig = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "config", "EnemyConfig").EnemyConfig
local _services = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services")
local ReplicatedStorage = _services.ReplicatedStorage
local RunService = _services.RunService
local Workspace = _services.Workspace
local enemyFolder = ReplicatedStorage.Assets.Enemies
local Enemy_C
do
	Enemy_C = setmetatable({}, {
		__tostring = function()
			return "Enemy_C"
		end,
	})
	Enemy_C.__index = Enemy_C
	function Enemy_C.new(...)
		local self = setmetatable({}, Enemy_C)
		return self:constructor(...) or self
	end
	function Enemy_C:constructor(id, enemyName)
		self.id = id
		self.position = Vector3.one
		self.timeSpawned = os.clock()
		self.info = EnemyConfig[enemyName]
		self.health = self.info.health
		self.instance = enemyFolder[enemyName]:Clone()
		self.instance.Parent = Workspace.Enemies
		self.trackController = Flamework.resolveDependency("client/controllers/TrackController@TrackController")
		self:startTravel()
	end
	function Enemy_C:startTravel()
		RunService.RenderStepped:Connect(function(dt)
			local elapsed = os.clock() - self.timeSpawned
			local pos = self.trackController:getPositionOnTrack(1, elapsed)
			-- Approximate movement direction using a small time step
			local futurePos = self.trackController:getPositionOnTrack(1, elapsed + dt)
			local dir = futurePos - pos
			self:moveTo(pos, dir)
		end)
	end
	function Enemy_C:moveTo(pos, lookDir)
		self.position = pos
		if not lookDir or lookDir.Magnitude <= 0 then
			self.instance:PivotTo(CFrame.new(pos))
			return nil
		end
		-- Current orientation
		local current = self.instance:GetPivot()
		-- Target orientation (facing movement direction)
		local _exp = pos
		local _pos = pos
		local _unit = lookDir.Unit
		local target = CFrame.lookAt(_exp, _pos + _unit)
		-- Adjust the alpha to control turn speed (closer to 1 = faster snap)
		local alpha = 0.1
		local smoothed = current:Lerp(target, alpha)
		self.instance:PivotTo(smoothed)
	end
	function Enemy_C:destroy()
		self.instance:Destroy()
	end
end
return {
	Enemy_C = Enemy_C,
}
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="17">
            <Properties>
              <string name="Name">Tower_C</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
              <ContentId name="LinkedSource">
                <null>
                </null>
              </ContentId>
              <bool name="DefinesCapabilities">false</bool>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local TowerConfig = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "config", "TowerConfig").TowerConfig
local _services = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services")
local ReplicatedStorage = _services.ReplicatedStorage
local RunService = _services.RunService
local Workspace = _services.Workspace
local Maid = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "maid", "Maid")
local _constants = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "constants")
local ATTR_ID = _constants.ATTR_ID
local ATTR_OWNER = _constants.ATTR_OWNER
local towerFolder = ReplicatedStorage.Assets.Towers
--[[
	*
	 * Includes instance
	 
]]
local Tower_C
do
	Tower_C = setmetatable({}, {
		__tostring = function()
			return "Tower_C"
		end,
	})
	Tower_C.__index = Tower_C
	function Tower_C.new(...)
		local self = setmetatable({}, Tower_C)
		return self:constructor(...) or self
	end
	function Tower_C:constructor(id, position, tower, enemyController, owner)
		self.id = id
		self.position = position
		self.enemyController = enemyController
		self.owner = owner
		self.damageDealt = 0
		self.targetMode = "First"
		self.maid = Maid.new()
		self.info = TowerConfig[tower]
		local towerInstance = towerFolder[tower]:Clone()
		towerInstance:PivotTo(CFrame.new(position))
		towerInstance.Parent = Workspace.Towers
		self.instance = towerInstance
		self.instance:SetAttribute(ATTR_ID, id)
		self.instance:SetAttribute(ATTR_OWNER, owner.Name)
		self.maid:GiveTask(RunService.RenderStepped:Connect(function()
			return self:faceTargetEnemy()
		end))
	end
	function Tower_C:faceTargetEnemy()
		local targetEnemy = self:findEnemy()
		if not targetEnemy then
			return nil
		end
		local enemyPos = targetEnemy.position
		local towerPos = self.instance:GetPivot().Position
		-- Only rotate left and right
		local lookAtPos = Vector3.new(enemyPos.X, towerPos.Y, enemyPos.Z)
		self.instance:PivotTo(CFrame.lookAt(towerPos, lookAtPos))
	end
	function Tower_C:findEnemy()
		local enemies = self.enemyController:getEnemies()
		if #enemies == 0 then
			return nil
		end
		if self.targetMode == "Closest" then
			local towerPos = self.position
			local closestEnemy
			local closestDistance = self.info.range
			-- ▼ ReadonlyArray.forEach ▼
			local _callback = function(enemy)
				-- GetPivot works on Models (returns CFrame of the root)
				local enemyPos = enemy.position
				local distance = (towerPos - enemyPos).Magnitude
				if distance < closestDistance then
					closestEnemy = enemy
					closestDistance = distance
				end
			end
			for _k, _v in enemies do
				_callback(_v, _k - 1, enemies)
			end
			-- ▲ ReadonlyArray.forEach ▲
			return closestEnemy
		else
			local towerPos = self.position
			-- ▼ ReadonlyArray.filter ▼
			local _newValue = {}
			local _callback = function(v)
				return v.health > 0
			end
			local _length = 0
			for _k, _v in enemies do
				if _callback(_v, _k - 1, enemies) == true then
					_length += 1
					_newValue[_length] = _v
				end
			end
			-- ▲ ReadonlyArray.filter ▲
			-- ▼ ReadonlyArray.filter ▼
			local _newValue_1 = {}
			local _callback_1 = function(enemy)
				local enemyPos = enemy.position
				return (towerPos - enemyPos).Magnitude <= self.info.range
			end
			local _length_1 = 0
			for _k, _v in _newValue do
				if _callback_1(_v, _k - 1, _newValue) == true then
					_length_1 += 1
					_newValue_1[_length_1] = _v
				end
			end
			-- ▲ ReadonlyArray.filter ▲
			local enemiesInRange = _newValue_1
			if #enemiesInRange == 0 then
				return nil
			end
			-- Pick the enemy with maximum progress (furthest along path)
			local _arg1 = enemiesInRange[1]
			-- ▼ ReadonlyArray.reduce ▼
			local _result = _arg1
			local _callback_2 = function(best, enemy)
				local enemyProgress = os.clock() - enemy.timeSpawned
				local bestProgress = os.clock() - best.timeSpawned
				if self.targetMode == "First" then
					return if enemyProgress > bestProgress then enemy else best
				else
					-- must be "Last"
					return if enemyProgress < bestProgress then enemy else best
				end
			end
			for _i = 1, #enemiesInRange do
				_result = _callback_2(_result, enemiesInRange[_i], _i - 1, enemiesInRange)
			end
			-- ▲ ReadonlyArray.reduce ▲
			return _result
		end
	end
	function Tower_C:destroy()
		self.instance:Destroy()
	end
end
return {
	Tower_C = Tower_C,
}
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="18">
          <Properties>
            <string name="Name">ui</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
            <bool name="DefinesCapabilities">false</bool>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
          <Item class="ModuleScript" referent="19">
            <Properties>
              <string name="Name">Tooltip</string>
              <BinaryString name="AttributesSerialize"></BinaryString>
              <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
              <ContentId name="LinkedSource">
                <null>
                </null>
              </ContentId>
              <bool name="DefinesCapabilities">false</bool>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local React = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "react")
local useAtom = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "react-charm").useAtom
local function TooltipUI(_param)
	local hoveredTower = _param.hoveredTower
	local visibleAtom = _param.visibleAtom
	local mousePosAtom = _param.mousePosAtom
	local ownerAtom = _param.ownerAtom
	local visible = useAtom(visibleAtom)
	local tower = useAtom(hoveredTower)
	local _binding = useAtom(mousePosAtom)
	local X = _binding.X
	local Y = _binding.Y
	local owner = useAtom(ownerAtom)
	local _attributes = {
		key = "TooltipText",
		Size = UDim2.fromScale(1, 1),
		BackgroundTransparency = 1,
	}
	local _condition = owner
	if _condition == nil then
		_condition = "N/A"
	end
	_attributes.Text = `{tower}\nOwned by: {_condition}`
	_attributes.TextColor3 = Color3.new(0.61, 0.32, 0.32)
	_attributes.TextStrokeColor3 = Color3.new(0, 0, 0)
	_attributes.TextStrokeTransparency = 0
	_attributes.TextScaled = true
	_attributes.ZIndex = 11
	_attributes.RichText = false
	return React.createElement("screengui", {
		ResetOnSpawn = false,
		key = "ToolTipGUI",
		IgnoreGuiInset = true,
		Enabled = visible,
	}, React.createElement("frame", {
		key = "TooltipContainer",
		AnchorPoint = Vector2.new(0, 0),
		Position = UDim2.fromOffset(X + 10, Y + 5),
		Size = UDim2.fromOffset(75, 40),
		BackgroundTransparency = 1,
		ZIndex = 10,
	}, React.createElement("textlabel", _attributes)))
end
return {
	TooltipUI = TooltipUI,
}
]]></string>
              <int64 name="SourceAssetId">-1</int64>
              <BinaryString name="Tags"></BinaryString>
            </Properties>
          </Item>
        </Item>
      </Item>
      <Item class="LocalScript" referent="20">
        <Properties>
          <string name="Name">RbxCharacterSounds</string>
          <BinaryString name="AttributesSerialize"></BinaryString>
          <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
          <bool name="Disabled">false</bool>
          <ContentId name="LinkedSource">
            <null>
            </null>
          </ContentId>
          <token name="RunContext">0</token>
          <bool name="DefinesCapabilities">false</bool>
          <string name="Source"><![CDATA[--!nonstrict
-- Roblox character sound script

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local SoundService = game:GetService("SoundService")

local AtomicBinding = require(script:WaitForChild("AtomicBinding"))

type Playable = Sound | AudioPlayer

local function loadFlag(flag: string)
	local success, result = pcall(function()
		return UserSettings():IsUserFeatureEnabled(flag)
	end)
	return success and result
end

local FFlagUserSoundsUseRelativeVelocity = loadFlag('UserSoundsUseRelativeVelocity2')
local FFlagUserNewCharacterSoundsApi = loadFlag('UserNewCharacterSoundsApi3')

local SOUND_DATA : { [string]: {[string]: any}} = {
	Climbing = {
		SoundId = "rbxasset://sounds/action_footsteps_plastic.mp3",
		Looped = true,
	},
	Died = {
		SoundId = "rbxasset://sounds/uuhhh.mp3",
	},
	FreeFalling = {
		SoundId = "rbxasset://sounds/action_falling.ogg",
		Looped = true,
	},
	GettingUp = {
		SoundId = "rbxasset://sounds/action_get_up.mp3",
	},
	Jumping = {
		SoundId = "rbxasset://sounds/action_jump.mp3",
	},
	Landing = {
		SoundId = "rbxasset://sounds/action_jump_land.mp3",
	},
	Running = {
		SoundId = "rbxasset://sounds/action_footsteps_plastic.mp3",
		Looped = true,
		Pitch = 1.85,
	},
	Splash = {
		SoundId = "rbxasset://sounds/impact_water.mp3",
	},
	Swimming = {
		SoundId = "rbxasset://sounds/action_swim.mp3",
		Looped = true,
		Pitch = 1.6,
	},
}

local AUDIOPLAYER_DATA : { [string]: {[string]: any}} = {
	Climbing = {
		AssetId = "rbxasset://sounds/action_footsteps_plastic.mp3",
		Looping = true,
	},
	Died = {
		AssetId = "rbxasset://sounds/uuhhh.mp3",
	},
	FreeFalling = {
		AssetId = "rbxasset://sounds/action_falling.ogg",
		Looping = true,
	},
	GettingUp = {
		AssetId = "rbxasset://sounds/action_get_up.mp3",
	},
	Jumping = {
		AssetId = "rbxasset://sounds/action_jump.mp3",
	},
	Landing = {
		AssetId = "rbxasset://sounds/action_jump_land.mp3",
	},
	Running = {
		AssetId = "rbxasset://sounds/action_footsteps_plastic.mp3",
		Looping = true,
		PlaybackSpeed = 1.85,
	},
	Splash = {
		AssetId = "rbxasset://sounds/impact_water.mp3",
	},
	Swimming = {
		AssetId = "rbxasset://sounds/action_swim.mp3",
		Looping = true,
		PlaybackSpeed = 1.6,
	},
}

-- map a value from one range to another
local function map(x: number, inMin: number, inMax: number, outMin: number, outMax: number): number
	return (x - inMin)*(outMax - outMin)/(inMax - inMin) + outMin
end

local function getRelativeVelocity(cm, velocity)
	if not cm then
		return velocity
	end
	local activeSensor = cm.ActiveController and
	(
		(cm.ActiveController:IsA("GroundController") and cm.GroundSensor) or
		(cm.ActiveController:IsA("ClimbController") and cm.ClimbSensor)
	)
	if activeSensor and activeSensor.SensedPart then
		-- Calculate the platform relative velocity by subtracting the velocity of the surface we're attached to or standing on.
		local platformVelocity = activeSensor.SensedPart:GetVelocityAtPosition(cm.RootPart.Position)
		return velocity - platformVelocity
	end
	return velocity
end

local function playSound(sound: Playable, continue: boolean?)
	if not continue then
		(sound :: any).TimePosition = 0
	end
	if FFlagUserNewCharacterSoundsApi and sound:IsA("AudioPlayer") then
		sound:Play()
	else
		(sound :: Sound).Playing = true
	end
end

local function stopSound(sound: Playable)
	if FFlagUserNewCharacterSoundsApi and sound:IsA("AudioPlayer") then
		sound:Stop()
	else
		(sound :: Sound).Playing = false
	end
end

local function playSoundIf(sound: Playable, condition: boolean)
	if FFlagUserNewCharacterSoundsApi and sound:IsA("AudioPlayer") then
		if (sound.IsPlaying and not condition) then
			sound:Stop()
		elseif (not sound.IsPlaying and condition) then
			sound:Play()
		end
	else
		(sound :: Sound).Playing = condition
	end
end

local function setSoundLooped(sound: Playable, isLooped: boolean)
	if FFlagUserNewCharacterSoundsApi and sound:IsA("AudioPlayer") then
		sound.Looping = isLooped
	else
		(sound :: Sound).Looped = isLooped
	end
end

local function shallowCopy(t)
	local out = {}
	for k, v in pairs(t) do
		out[k] = v
	end
	return out
end

local function initializeSoundSystem(instances: { [string]: Instance })
	local humanoid = instances.humanoid
	local rootPart = instances.rootPart
	local audioEmitter = nil
	local cm = nil
	if FFlagUserSoundsUseRelativeVelocity then
		local character = humanoid.Parent
		cm = character:FindFirstChild('ControllerManager')
	end

	local sounds: {[string]: Playable} = {}

	if FFlagUserNewCharacterSoundsApi and SoundService.CharacterSoundsUseNewApi == Enum.RolloutState.Enabled then
		-- initialize Audio Emitter
		local localPlayer = Players.LocalPlayer
		local character = localPlayer.Character
		local curve = {}
		local i : number = 5
		local step : number = 1.25 -- determines how fine-grained the curve gets sampled
		while i < 150 do
			curve[i] = 5 / i;
			i *= step;
		end
		curve[150] = 0
		audioEmitter = Instance.new("AudioEmitter", character)
		audioEmitter.Name = "RbxCharacterSoundsEmitter"
		audioEmitter:SetDistanceAttenuation(curve)
		-- initialize sounds
		for name: string, props: {[string]: any} in pairs(AUDIOPLAYER_DATA) do
			local sound = Instance.new("AudioPlayer")
			local audioPlayerWire: Wire = Instance.new("Wire")
			sound.Name = name
			audioPlayerWire.Name = name .. "Wire"
			-- set default values
			sound.Archivable = false
			sound.Volume = 0.65
			for propName, propValue: any in pairs(props) do
				(sound :: any)[propName] = propValue
			end
			sound.Parent = rootPart
			audioPlayerWire.Parent = sound
			audioPlayerWire.SourceInstance = sound
			audioPlayerWire.TargetInstance = audioEmitter
			sounds[name] = sound
		end
	else
		-- initialize sounds
		for name: string, props: {[string]: any} in pairs(SOUND_DATA) do
			local sound = Instance.new("Sound")
			sound.Name = name
			-- set default values
			sound.Archivable = false
			sound.RollOffMinDistance = 5
			sound.RollOffMaxDistance = 150
			sound.Volume = 0.65
			for propName, propValue: any in pairs(props) do
				(sound :: any)[propName] = propValue
			end
			sound.Parent = rootPart
			sounds[name] = sound
		end
	end

	local playingLoopedSounds: {[Playable]: boolean?} = {}

	local function stopPlayingLoopedSounds(except: Playable?)
		except = except or nil --default value
		for sound in pairs(shallowCopy(playingLoopedSounds)) do
			if sound ~= except then
				stopSound(sound)
				playingLoopedSounds[sound] = nil
			end
		end
	end

	-- state transition callbacks.
	local stateTransitions: {[Enum.HumanoidStateType]: () -> ()} = {
		[Enum.HumanoidStateType.FallingDown] = function()
			stopPlayingLoopedSounds()
		end,

		[Enum.HumanoidStateType.GettingUp] = function()
			stopPlayingLoopedSounds()
			playSound(sounds.GettingUp)
		end,

		[Enum.HumanoidStateType.Jumping] = function()
			stopPlayingLoopedSounds()
			playSound(sounds.Jumping)
		end,

		[Enum.HumanoidStateType.Swimming] = function()
			local verticalSpeed = math.abs(rootPart.AssemblyLinearVelocity.Y)
			if verticalSpeed > 0.1 then
				(sounds.Splash :: any).Volume = math.clamp(map(verticalSpeed, 100, 350, 0.28, 1), 0, 1)
				playSound(sounds.Splash)
			end
			stopPlayingLoopedSounds(sounds.Swimming)
			playSound(sounds.Swimming, true)
			playingLoopedSounds[sounds.Swimming] = true
		end,

		[Enum.HumanoidStateType.Freefall] = function()
			(sounds.FreeFalling :: any).Volume = 0
			stopPlayingLoopedSounds(sounds.FreeFalling)
			
			setSoundLooped(sounds.FreeFalling, true)
			if sounds.FreeFalling:IsA("Sound") then
				sounds.FreeFalling.PlaybackRegionsEnabled = true
			end
			(sounds.FreeFalling :: any).LoopRegion = NumberRange.new(2, 9)
			playSound(sounds.FreeFalling)
			
			playingLoopedSounds[sounds.FreeFalling] = true
		end,

		[Enum.HumanoidStateType.Landed] = function()
			stopPlayingLoopedSounds()
			local verticalSpeed = math.abs(rootPart.AssemblyLinearVelocity.Y)
			if verticalSpeed > 75 then
				(sounds.Landing :: any).Volume = math.clamp(map(verticalSpeed, 50, 100, 0, 1), 0, 1)
				playSound(sounds.Landing)
			end
		end,

		[Enum.HumanoidStateType.Running] = function()
			stopPlayingLoopedSounds(sounds.Running)
			playSound(sounds.Running, true)
			playingLoopedSounds[sounds.Running] = true
		end,

		[Enum.HumanoidStateType.Climbing] = function()
			local sound = sounds.Climbing
			local partVelocity = rootPart.AssemblyLinearVelocity
			local velocity = if FFlagUserSoundsUseRelativeVelocity then getRelativeVelocity(cm, partVelocity) else partVelocity
			if math.abs(velocity.Y) > 0.1 then
				playSound(sound, true)
				stopPlayingLoopedSounds(sound)
			else
				stopPlayingLoopedSounds()
			end
			playingLoopedSounds[sound] = true
		end,

		[Enum.HumanoidStateType.Seated] = function()
			stopPlayingLoopedSounds()
		end,

		[Enum.HumanoidStateType.Dead] = function()
			stopPlayingLoopedSounds()
			playSound(sounds.Died)
		end,
	}

	-- updaters for looped sounds
	local loopedSoundUpdaters: {[Playable]: (number, Playable, Vector3) -> ()} = {
		[sounds.Climbing] = function(dt: number, sound: Playable, vel: Vector3)
			local velocity = if FFlagUserSoundsUseRelativeVelocity then getRelativeVelocity(cm, vel) else vel
			playSoundIf(sound, velocity.Magnitude > 0.1)
		end,

		[sounds.FreeFalling] = function(dt: number, sound: Playable, vel: Vector3): ()
			if vel.Magnitude > 75 then
				(sound :: any).Volume = math.clamp((sound :: any).Volume + 0.9*dt, 0, 1)
			else
				(sound :: any).Volume = 0
			end
		end,

		[sounds.Running] = function(dt: number, sound: Playable, vel: Vector3)
			playSoundIf(sound, vel.Magnitude > 0.5 and humanoid.MoveDirection.Magnitude > 0.5)
		end,
	}

	-- state substitutions to avoid duplicating entries in the state table
	local stateRemap: {[Enum.HumanoidStateType]: Enum.HumanoidStateType} = {
		[Enum.HumanoidStateType.RunningNoPhysics] = Enum.HumanoidStateType.Running,
	}

	local activeState: Enum.HumanoidStateType = stateRemap[humanoid:GetState()] or humanoid:GetState()

	local function transitionTo(state)
		local transitionFunc: () -> () = stateTransitions[state]

		if transitionFunc then
			transitionFunc()
		end

		activeState = state
	end

	transitionTo(activeState)

	local stateChangedConn = humanoid.StateChanged:Connect(function(_, state)
		state = stateRemap[state] or state

		if state ~= activeState then
			transitionTo(state)
		end
	end)

	local steppedConn = RunService.Stepped:Connect(function(_, worldDt: number)
		-- update looped sounds on stepped
		for sound in pairs(playingLoopedSounds) do
			local updater: (number, Playable, Vector3) -> () = loopedSoundUpdaters[sound]

			if updater then
				updater(worldDt, sound, rootPart.AssemblyLinearVelocity)
			end
		end
	end)

	local function terminate()
		stateChangedConn:Disconnect()
		steppedConn:Disconnect()

		-- Unparent all sounds and empty sounds table
		-- This is needed in order to support the case where initializeSoundSystem might be called more than once for the same player,
		-- which might happen in case player character is unparented and parented back on server and reset-children mechanism is active.
		for name: string, sound: Playable in pairs(sounds) do
			sound:Destroy()
		end
		table.clear(sounds)
	end

	return terminate
end

local binding = AtomicBinding.new({
	humanoid = "Humanoid",
	rootPart = "HumanoidRootPart",
}, initializeSoundSystem)

local playerConnections = {}

local function characterAdded(character)
	binding:bindRoot(character)
end

local function characterRemoving(character)
	binding:unbindRoot(character)
end

local function playerAdded(player: Player)
	local connections = playerConnections[player]
	if not connections then
		connections = {}
		playerConnections[player] = connections
	end

	if player.Character then
		characterAdded(player.Character)
	end
	table.insert(connections, player.CharacterAdded:Connect(characterAdded))
	table.insert(connections, player.CharacterRemoving:Connect(characterRemoving))
end

local function playerRemoving(player: Player)
	local connections = playerConnections[player]
	if connections then
		for _, conn in ipairs(connections) do
			conn:Disconnect()
		end
		playerConnections[player] = nil
	end

	if player.Character then
		characterRemoving(player.Character)
	end
end

for _, player in ipairs(Players:GetPlayers()) do
	task.spawn(playerAdded, player)
end
Players.PlayerAdded:Connect(playerAdded)
Players.PlayerRemoving:Connect(playerRemoving)
]]></string>
          <int64 name="SourceAssetId">-1</int64>
          <BinaryString name="Tags"></BinaryString>
        </Properties>
        <Item class="ModuleScript" referent="21">
          <Properties>
            <string name="Name">AtomicBinding</string>
            <BinaryString name="AttributesSerialize"></BinaryString>
            <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
            <ContentId name="LinkedSource">
              <null>
              </null>
            </ContentId>
            <bool name="DefinesCapabilities">false</bool>
            <string name="Source"><![CDATA[--!nonstrict
local ROOT_ALIAS = "root"

local function parsePath(pathStr)
	local pathArray = string.split(pathStr, "/")
	for idx = #pathArray, 1, -1 do
		if pathArray[idx] == "" then
			table.remove(pathArray, idx)
		end
	end
	return pathArray
end

local function isManifestResolved(resolvedManifest, manifestSizeTarget)
	local manifestSize = 0
	for _ in pairs(resolvedManifest) do
		manifestSize += 1
	end

	assert(manifestSize <= manifestSizeTarget, manifestSize)
	return manifestSize == manifestSizeTarget
end

local function unbindNodeDescend(node, resolvedManifest)
	if node.instance == nil then
		return -- Do not try to unbind nodes that are already unbound
	end

	node.instance = nil

	local connections = node.connections
	if connections then
		for _, conn in ipairs(connections) do
			conn:Disconnect()
		end
		table.clear(connections)
	end

	if resolvedManifest and node.alias then
		resolvedManifest[node.alias] = nil
	end

	local children = node.children
	if children then
		for _, childNode in pairs(children) do
			unbindNodeDescend(childNode, resolvedManifest)
		end
	end
end

local AtomicBinding = {}
AtomicBinding.__index = AtomicBinding

function AtomicBinding.new(manifest, boundFn)
	local dtorMap = {} -- { [root] -> dtor }
	local connections = {} -- { Connection, ... }
	local rootInstToRootNode = {} -- { [root] -> rootNode }
	local rootInstToManifest = {} -- { [root] -> { [alias] -> instance } }

	local parsedManifest = {} -- { [alias] = {Name, ...} }
	local manifestSizeTarget = 1 -- Add 1 because root isn't explicitly on the manifest	
	
	for alias, rawPath in pairs(manifest) do
		parsedManifest[alias] = parsePath(rawPath)
		manifestSizeTarget += 1
	end

	return setmetatable({
		_boundFn = boundFn,
		_parsedManifest = parsedManifest,
		_manifestSizeTarget = manifestSizeTarget,
		
		_dtorMap = dtorMap,
		_connections = connections,
		_rootInstToRootNode = rootInstToRootNode,
		_rootInstToManifest = rootInstToManifest,
	}, AtomicBinding)
end

function AtomicBinding:_startBoundFn(root, resolvedManifest)
	local boundFn = self._boundFn
	local dtorMap = self._dtorMap
	
	local oldDtor = dtorMap[root]
	if oldDtor then
		oldDtor()
		dtorMap[root] = nil
	end

	local dtor = boundFn(resolvedManifest)
	if dtor then
		dtorMap[root] = dtor
	end
end

function AtomicBinding:_stopBoundFn(root)
	local dtorMap = self._dtorMap
	
	local dtor = dtorMap[root]
	if dtor then
		dtor()
		dtorMap[root] = nil
	end
end

function AtomicBinding:bindRoot(root)
	debug.profilebegin("AtomicBinding:BindRoot")
	
	local parsedManifest = self._parsedManifest
	local rootInstToRootNode = self._rootInstToRootNode
	local rootInstToManifest = self._rootInstToManifest
	local manifestSizeTarget = self._manifestSizeTarget
	
	assert(rootInstToManifest[root] == nil)

	local resolvedManifest = {}
	rootInstToManifest[root] = resolvedManifest

	debug.profilebegin("BuildTree")

	local rootNode = {}
	rootNode.alias = ROOT_ALIAS
	rootNode.instance = root
	if next(parsedManifest) then
		-- No need to assign child data if there are no children
		rootNode.children = {}
		rootNode.connections = {}
	end

	rootInstToRootNode[root] = rootNode

	for alias, parsedPath in pairs(parsedManifest) do
		local parentNode = rootNode

		for idx, childName in ipairs(parsedPath) do
			local leaf = idx == #parsedPath
			local childNode = parentNode.children[childName] or {}

			if leaf then
				if childNode.alias ~= nil then
					error("Multiple aliases assigned to one instance")
				end

				childNode.alias = alias

			else
				childNode.children = childNode.children or {}
				childNode.connections = childNode.connections or {}
			end

			parentNode.children[childName] = childNode
			parentNode = childNode
		end
	end

	debug.profileend() -- BuildTree

	-- Recursively descend into the tree, resolving each node.
	-- Nodes start out as empty and instance-less; the resolving process discovers instances to map to nodes.
	local function processNode(node)
		local instance = assert(node.instance)

		local children = node.children
		local alias = node.alias
		local isLeaf = not children

		if alias then
			resolvedManifest[alias] = instance
		end

		if not isLeaf then
			local function processAddChild(childInstance)
				local childName = childInstance.Name
				local childNode = children[childName]
				if not childNode or childNode.instance ~= nil then
					return
				end

				childNode.instance = childInstance
				processNode(childNode)
			end

			local function processDeleteChild(childInstance)
				-- Instance deletion - Parent A detects that child B is being removed
				--    1. A removes B from `children`
				--    2. A traverses down from B,
				--       i.  Disconnecting inputs
				--       ii. Removing nodes from the resolved manifest
				--    3. stopBoundFn is called because we know the tree is no longer complete, or at least has to be refreshed
				-- 	  4. We search A for a replacement for B, and attempt to re-resolve using that replacement if it exists.
				-- To support the above sanely, processAddChild needs to avoid resolving nodes that are already resolved.

				local childName = childInstance.Name
				local childNode = children[childName]

				if not childNode then
					return -- There's no child node corresponding to the deleted instance, ignore
				end

				if childNode.instance ~= childInstance then
					return -- A child was removed with the same name as a node instance, ignore
				end

				self:_stopBoundFn(root) -- Happens before the tree is unbound so the manifest is still valid in the destructor.
				unbindNodeDescend(childNode, resolvedManifest) -- Unbind the tree

				assert(childNode.instance == nil) -- If this triggers, unbindNodeDescend failed

				-- Search for a replacement
				local replacementChild = instance:FindFirstChild(childName)
				if replacementChild then
					processAddChild(replacementChild)
				end
			end

			for _, child in ipairs(instance:GetChildren()) do
				processAddChild(child)
			end

			table.insert(node.connections, instance.ChildAdded:Connect(processAddChild))
			table.insert(node.connections, instance.ChildRemoved:Connect(processDeleteChild))
		end

		if isLeaf and isManifestResolved(resolvedManifest, manifestSizeTarget) then
			self:_startBoundFn(root, resolvedManifest)
		end
	end

	debug.profilebegin("ResolveTree")
	processNode(rootNode)
	debug.profileend() -- ResolveTree
	
	debug.profileend() -- AtomicBinding:BindRoot
end

function AtomicBinding:unbindRoot(root)
	local rootInstToRootNode = self._rootInstToRootNode
	local rootInstToManifest = self._rootInstToManifest
	
	self:_stopBoundFn(root)

	local rootNode = rootInstToRootNode[root]
	if rootNode then
		local resolvedManifest = assert(rootInstToManifest[root])
		unbindNodeDescend(rootNode, resolvedManifest)
		rootInstToRootNode[root] = nil
	end

	rootInstToManifest[root] = nil
end

function AtomicBinding:destroy()
	debug.profilebegin("AtomicBinding:destroy")

	for _, dtor in pairs(self._dtorMap) do
		dtor:destroy()
	end
	table.clear(self._dtorMap)

	for _, conn in ipairs(self._connections) do
		conn:Disconnect()
	end
	table.clear(self._connections)

	local rootInstToManifest = self._rootInstToManifest
	for rootInst, rootNode in pairs(self._rootInstToRootNode) do
		local resolvedManifest = assert(rootInstToManifest[rootInst])
		unbindNodeDescend(rootNode, resolvedManifest)
	end
	table.clear(self._rootInstToManifest)
	table.clear(self._rootInstToRootNode)

	debug.profileend()
end

return AtomicBinding
]]></string>
            <int64 name="SourceAssetId">-1</int64>
            <BinaryString name="Tags"></BinaryString>
          </Properties>
        </Item>
      </Item>
    </Item>
    <Item class="StarterCharacterScripts" referent="22">
      <Properties>
        <string name="Name">StarterCharacterScripts</string>
        <BinaryString name="AttributesSerialize"></BinaryString>
        <SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
        <bool name="DefinesCapabilities">false</bool>
        <int64 name="SourceAssetId">-1</int64>
        <BinaryString name="Tags"></BinaryString>
      </Properties>
    </Item>
    <Item class="StarterPlayerScripts" referent="23">
      <Properties>
        <string name="Name">StarterPlayerScripts</string>
      </Properties>
      <Item class="Folder" referent="24">
        <Properties>
          <string name="Name">TS</string>
        </Properties>
        <Item class="Folder" referent="25">
          <Properties>
            <string name="Name">classes</string>
          </Properties>
          <Item class="ModuleScript" referent="26">
            <Properties>
              <string name="Name">Enemy_C</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Flamework = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Flamework
local EnemyConfig = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "config", "EnemyConfig").EnemyConfig
local _services = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services")
local ReplicatedStorage = _services.ReplicatedStorage
local RunService = _services.RunService
local Workspace = _services.Workspace
local enemyFolder = ReplicatedStorage.Assets.Enemies
local Enemy_C
do
	Enemy_C = setmetatable({}, {
		__tostring = function()
			return "Enemy_C"
		end,
	})
	Enemy_C.__index = Enemy_C
	function Enemy_C.new(...)
		local self = setmetatable({}, Enemy_C)
		return self:constructor(...) or self
	end
	function Enemy_C:constructor(id, enemyName)
		self.id = id
		self.position = Vector3.one
		self.timeSpawned = os.clock()
		self.info = EnemyConfig[enemyName]
		self.health = self.info.health
		self.instance = enemyFolder[enemyName]:Clone()
		self.instance.Parent = Workspace.Enemies
		self.trackController = Flamework.resolveDependency("client/controllers/TrackController@TrackController")
		self:startTravel()
	end
	function Enemy_C:startTravel()
		RunService.RenderStepped:Connect(function(dt)
			local elapsed = os.clock() - self.timeSpawned
			local pos = self.trackController:getPositionOnTrack(1, elapsed)
			-- Approximate movement direction using a small time step
			local futurePos = self.trackController:getPositionOnTrack(1, elapsed + dt)
			local dir = futurePos - pos
			self:moveTo(pos, dir)
		end)
	end
	function Enemy_C:moveTo(pos, lookDir)
		self.position = pos
		if not lookDir or lookDir.Magnitude <= 0 then
			self.instance:PivotTo(CFrame.new(pos))
			return nil
		end
		-- Current orientation
		local current = self.instance:GetPivot()
		-- Target orientation (facing movement direction)
		local _exp = pos
		local _pos = pos
		local _unit = lookDir.Unit
		local target = CFrame.lookAt(_exp, _pos + _unit)
		-- Adjust the alpha to control turn speed (closer to 1 = faster snap)
		local alpha = 0.1
		local smoothed = current:Lerp(target, alpha)
		self.instance:PivotTo(smoothed)
	end
	function Enemy_C:destroy()
		self.instance:Destroy()
	end
end
return {
	Enemy_C = Enemy_C,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="27">
            <Properties>
              <string name="Name">Tower_C</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local TowerConfig = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "config", "TowerConfig").TowerConfig
local _services = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services")
local ReplicatedStorage = _services.ReplicatedStorage
local RunService = _services.RunService
local Workspace = _services.Workspace
local Maid = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "maid", "Maid")
local _constants = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "constants")
local ATTR_ID = _constants.ATTR_ID
local ATTR_OWNER = _constants.ATTR_OWNER
local towerFolder = ReplicatedStorage.Assets.Towers
--[[
	*
	 * Includes instance
	 
]]
local Tower_C
do
	Tower_C = setmetatable({}, {
		__tostring = function()
			return "Tower_C"
		end,
	})
	Tower_C.__index = Tower_C
	function Tower_C.new(...)
		local self = setmetatable({}, Tower_C)
		return self:constructor(...) or self
	end
	function Tower_C:constructor(id, position, tower, enemyController, owner)
		self.id = id
		self.position = position
		self.enemyController = enemyController
		self.owner = owner
		self.damageDealt = 0
		self.targetMode = "First"
		self.maid = Maid.new()
		self.info = TowerConfig[tower]
		local towerInstance = towerFolder[tower]:Clone()
		towerInstance:PivotTo(CFrame.new(position))
		towerInstance.Parent = Workspace.Towers
		self.instance = towerInstance
		self.instance:SetAttribute(ATTR_ID, id)
		self.instance:SetAttribute(ATTR_OWNER, owner.Name)
		self.maid:GiveTask(RunService.RenderStepped:Connect(function()
			return self:faceTargetEnemy()
		end))
	end
	function Tower_C:faceTargetEnemy()
		local targetEnemy = self:findEnemy()
		if not targetEnemy then
			return nil
		end
		local enemyPos = targetEnemy.position
		local towerPos = self.instance:GetPivot().Position
		-- Only rotate left and right
		local lookAtPos = Vector3.new(enemyPos.X, towerPos.Y, enemyPos.Z)
		self.instance:PivotTo(CFrame.lookAt(towerPos, lookAtPos))
	end
	function Tower_C:findEnemy()
		local enemies = self.enemyController:getEnemies()
		if #enemies == 0 then
			return nil
		end
		if self.targetMode == "Closest" then
			local towerPos = self.position
			local closestEnemy
			local closestDistance = self.info.range
			-- ▼ ReadonlyArray.forEach ▼
			local _callback = function(enemy)
				-- GetPivot works on Models (returns CFrame of the root)
				local enemyPos = enemy.position
				local distance = (towerPos - enemyPos).Magnitude
				if distance < closestDistance then
					closestEnemy = enemy
					closestDistance = distance
				end
			end
			for _k, _v in enemies do
				_callback(_v, _k - 1, enemies)
			end
			-- ▲ ReadonlyArray.forEach ▲
			return closestEnemy
		else
			local towerPos = self.position
			-- ▼ ReadonlyArray.filter ▼
			local _newValue = {}
			local _callback = function(v)
				return v.health > 0
			end
			local _length = 0
			for _k, _v in enemies do
				if _callback(_v, _k - 1, enemies) == true then
					_length += 1
					_newValue[_length] = _v
				end
			end
			-- ▲ ReadonlyArray.filter ▲
			-- ▼ ReadonlyArray.filter ▼
			local _newValue_1 = {}
			local _callback_1 = function(enemy)
				local enemyPos = enemy.position
				return (towerPos - enemyPos).Magnitude <= self.info.range
			end
			local _length_1 = 0
			for _k, _v in _newValue do
				if _callback_1(_v, _k - 1, _newValue) == true then
					_length_1 += 1
					_newValue_1[_length_1] = _v
				end
			end
			-- ▲ ReadonlyArray.filter ▲
			local enemiesInRange = _newValue_1
			if #enemiesInRange == 0 then
				return nil
			end
			-- Pick the enemy with maximum progress (furthest along path)
			local _arg1 = enemiesInRange[1]
			-- ▼ ReadonlyArray.reduce ▼
			local _result = _arg1
			local _callback_2 = function(best, enemy)
				local enemyProgress = os.clock() - enemy.timeSpawned
				local bestProgress = os.clock() - best.timeSpawned
				if self.targetMode == "First" then
					return if enemyProgress > bestProgress then enemy else best
				else
					-- must be "Last"
					return if enemyProgress < bestProgress then enemy else best
				end
			end
			for _i = 1, #enemiesInRange do
				_result = _callback_2(_result, enemiesInRange[_i], _i - 1, enemiesInRange)
			end
			-- ▲ ReadonlyArray.reduce ▲
			return _result
		end
	end
	function Tower_C:destroy()
		self.instance:Destroy()
	end
end
return {
	Tower_C = Tower_C,
}
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="Folder" referent="28">
          <Properties>
            <string name="Name">components</string>
          </Properties>
        </Item>
        <Item class="Folder" referent="29">
          <Properties>
            <string name="Name">controllers</string>
          </Properties>
          <Item class="ModuleScript" referent="30">
            <Properties>
              <string name="Name">ClientStateProvider</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Reflect = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Reflect
local _core = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out")
local Controller = _core.Controller
local Modding = _core.Modding
local atom = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "charm").atom
local Events = TS.import(script, script.Parent.Parent, "networking").Events
local t = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "t", "lib", "ts").t
local SYNC_KEYS = Modding.inspect({ "money", "exp", "rebirth", "inventory" })
local tSyncKey = t.literal("money", "exp", "rebirth", "inventory")
local ClientStateProvider
do
	ClientStateProvider = setmetatable({}, {
		__tostring = function()
			return "ClientStateProvider"
		end,
	})
	ClientStateProvider.__index = ClientStateProvider
	function ClientStateProvider.new(...)
		local self = setmetatable({}, ClientStateProvider)
		return self:constructor(...) or self
	end
	function ClientStateProvider:constructor()
		self.selectedTower = atom("None")
		self.playerState = {}
		for _, key in SYNC_KEYS do
			(self.playerState)[key] = atom(nil)
		end
	end
	function ClientStateProvider:onInit()
		Events.playerStateChanged:connect(function(key, state, prev)
			if not tSyncKey(key) then
				return nil
			end
			self.playerState[key](state)
		end)
	end
	do
		-- (Flamework) ClientStateProvider metadata
		Reflect.defineMetadata(ClientStateProvider, "identifier", "client/controllers/ClientStateProvider@ClientStateProvider")
		Reflect.defineMetadata(ClientStateProvider, "flamework:implements", { "$:flamework@OnInit" })
	end
end
-- (Flamework) ClientStateProvider decorators
Reflect.decorate(ClientStateProvider, "$:flamework@Controller", Controller, { {} })
return {
	ClientStateProvider = ClientStateProvider,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="31">
            <Properties>
              <string name="Name">EnemyController</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Reflect = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Reflect
local Controller = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Controller
local Enemy_C = TS.import(script, script.Parent.Parent, "classes", "Enemy_C").Enemy_C
local Events = TS.import(script, script.Parent.Parent, "networking").Events
local EnemyController
do
	EnemyController = setmetatable({}, {
		__tostring = function()
			return "EnemyController"
		end,
	})
	EnemyController.__index = EnemyController
	function EnemyController.new(...)
		local self = setmetatable({}, EnemyController)
		return self:constructor(...) or self
	end
	function EnemyController:constructor()
		self.enemies = {}
	end
	function EnemyController:onStart()
		Events.enemySpawned:connect(function(i, e)
			return self:onEnemySpawned(i, e)
		end)
		Events.enemyDeleted:connect(function(i)
			return self:onEnemyDeleted(i)
		end)
		Events.updateEnemyHealth:connect(function(i, v)
			return self:onEnemyHealthUpdated(i, v)
		end)
	end
	function EnemyController:getEnemies()
		local _array = {}
		local _length = #_array
		for _k, _v in self.enemies do
			_length += 1
			_array[_length] = { _k, _v }
		end
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#_array)
		local _callback = function(v)
			return v[2]
		end
		for _k, _v in _array do
			_newValue[_k] = _callback(_v, _k - 1, _array)
		end
		-- ▲ ReadonlyArray.map ▲
		return _newValue
	end
	function EnemyController:onEnemySpawned(id, enemy)
		local newEnemy = Enemy_C.new(id, enemy)
		local _enemies = self.enemies
		local _id = id
		_enemies[_id] = newEnemy
	end
	function EnemyController:onEnemyDeleted(id)
		local _enemies = self.enemies
		local _id = id
		_enemies[_id]:destroy()
		local _enemies_1 = self.enemies
		local _id_1 = id
		_enemies_1[_id_1] = nil
	end
	function EnemyController:onEnemyHealthUpdated(id, value)
		local _enemies = self.enemies
		local _id = id
		_enemies[_id].health = value
	end
	do
		-- (Flamework) EnemyController metadata
		Reflect.defineMetadata(EnemyController, "identifier", "client/controllers/EnemyController@EnemyController")
		Reflect.defineMetadata(EnemyController, "flamework:implements", { "$:flamework@OnStart" })
	end
end
-- (Flamework) EnemyController decorators
Reflect.decorate(EnemyController, "$:flamework@Controller", Controller, { {} })
return {
	EnemyController = EnemyController,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="32">
            <Properties>
              <string name="Name">InventoryController</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Reflect = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Reflect
local Controller = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Controller
local Players = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").Players
local Signal = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "lemon-signal", "src").default
local player = Players.LocalPlayer
local InventoryController
do
	InventoryController = setmetatable({}, {
		__tostring = function()
			return "InventoryController"
		end,
	})
	InventoryController.__index = InventoryController
	function InventoryController.new(...)
		local self = setmetatable({}, InventoryController)
		return self:constructor(...) or self
	end
	function InventoryController:constructor(stateProvider)
		self.stateProvider = stateProvider
		self.playerStoppedHoldingTower = Signal.new()
	end
	function InventoryController:onStart()
	end
	do
		-- (Flamework) InventoryController metadata
		Reflect.defineMetadata(InventoryController, "identifier", "client/controllers/InventoryController@InventoryController")
		Reflect.defineMetadata(InventoryController, "flamework:parameters", { "client/controllers/ClientStateProvider@ClientStateProvider" })
		Reflect.defineMetadata(InventoryController, "flamework:implements", { "$:flamework@OnStart" })
	end
end
-- (Flamework) InventoryController decorators
Reflect.decorate(InventoryController, "$:flamework@Controller", Controller, { {} })
return {
	InventoryController = InventoryController,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="33">
            <Properties>
              <string name="Name">TooltipController</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Reflect = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Reflect
local Controller = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Controller
local _services = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services")
local CollectionService = _services.CollectionService
local Players = _services.Players
local RunService = _services.RunService
local UserInputService = _services.UserInputService
local Workspace = _services.Workspace
local _constants = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "constants")
local ATTR_OWNER = _constants.ATTR_OWNER
local TOOLTIPS_ENABLED = _constants.TOOLTIPS_ENABLED
local atom = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "charm").atom
local createRoot = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "react-roblox").createRoot
local React = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "react")
local TAG_TOWER = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "constants").TAG_TOWER
local findFirstAncestorWithTag = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "util", "findFirstAncestorWithTag").findFirstAncestorWithTag
local TooltipUI = TS.import(script, script.Parent.Parent, "ui", "Tooltip").TooltipUI
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local camera = Workspace.CurrentCamera
local TooltipController
do
	TooltipController = setmetatable({}, {
		__tostring = function()
			return "TooltipController"
		end,
	})
	TooltipController.__index = TooltipController
	function TooltipController.new(...)
		local self = setmetatable({}, TooltipController)
		return self:constructor(...) or self
	end
	function TooltipController:constructor(stateProvider)
		self.stateProvider = stateProvider
		self.isPlacing = false
	end
	function TooltipController:onStart()
		if TOOLTIPS_ENABLED then
			self:enableTowerTooltips()
		end
	end
	function TooltipController:enableTowerTooltips()
		local visible = atom(true)
		local mousePos = atom(Vector2.new(0, 0))
		local hoveredTower = atom("None")
		local towerOwnerAtom = atom()
		local root = createRoot(playerGui)
		root:render(React.createElement(TooltipUI, {
			hoveredTower = hoveredTower,
			visibleAtom = visible,
			mousePosAtom = mousePos,
			ownerAtom = towerOwnerAtom,
		}))
		RunService.RenderStepped:Connect(function(dt)
			if self.isPlacing then
				return nil
			end
			local _binding = UserInputService:GetMouseLocation()
			local X = _binding.X
			local Y = _binding.Y
			local _binding_1 = camera:ViewportPointToRay(X, Y)
			local Origin = _binding_1.Origin
			local Direction = _binding_1.Direction
			local rayParams = RaycastParams.new()
			rayParams.FilterType = Enum.RaycastFilterType.Include
			rayParams.FilterDescendantsInstances = CollectionService:GetTagged(TAG_TOWER)
			local rayResult = Workspace:Raycast(Origin, Direction * 1000, rayParams)
			if rayResult then
				local tower = findFirstAncestorWithTag(rayResult.Instance, TAG_TOWER)
				visible(true)
				mousePos(Vector2.new(X, Y))
				local _result = tower
				if _result ~= nil then
					_result = _result:GetAttribute(ATTR_OWNER)
				end
				towerOwnerAtom(_result)
				hoveredTower(if tower then (tower.Name) else "None")
			else
				visible(false)
			end
		end)
	end
	do
		-- (Flamework) TooltipController metadata
		Reflect.defineMetadata(TooltipController, "identifier", "client/controllers/TooltipController@TooltipController")
		Reflect.defineMetadata(TooltipController, "flamework:parameters", { "client/controllers/ClientStateProvider@ClientStateProvider" })
		Reflect.defineMetadata(TooltipController, "flamework:implements", { "$:flamework@OnStart" })
	end
end
-- (Flamework) TooltipController decorators
Reflect.decorate(TooltipController, "$:flamework@Controller", Controller, { {} })
return {
	TooltipController = TooltipController,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="34">
            <Properties>
              <string name="Name">TowerPlacementController</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Reflect = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Reflect
local Controller = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Controller
local _services = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services")
local Players = _services.Players
local ReplicatedStorage = _services.ReplicatedStorage
local RunService = _services.RunService
local UserInputService = _services.UserInputService
local Workspace = _services.Workspace
local Functions = TS.import(script, script.Parent.Parent, "networking").Functions
local TowerConfig = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "config", "TowerConfig").TowerConfig
local t = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "t", "lib", "ts").t
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")
local camera = Workspace.CurrentCamera
local towerFolder = ReplicatedStorage.Assets.Towers
local tTowerName = t.literal("None", "Barbarian", "Archer", "Cannon", "Sharpshooter")
--[[
	*
	 * Handles tower placement (preview, input, placement logic, etc.)
	 
]]
local makePartPreview
local TowerPlacementController
do
	TowerPlacementController = setmetatable({}, {
		__tostring = function()
			return "TowerPlacementController"
		end,
	})
	TowerPlacementController.__index = TowerPlacementController
	function TowerPlacementController.new(...)
		local self = setmetatable({}, TowerPlacementController)
		return self:constructor(...) or self
	end
	function TowerPlacementController:constructor(trackController, stateProvider)
		self.trackController = trackController
		self.stateProvider = stateProvider
		self.isPlacing = false
		self.rangePreview = Instance.new("Part")
		self.selectedTower = self.stateProvider.selectedTower
	end
	function TowerPlacementController:onStart()
		-- Setup range preview part
		self.rangePreview.Anchored = true
		self.rangePreview.CanCollide = false
		self.rangePreview.Transparency = 1
		self.rangePreview.Material = Enum.Material.Neon
		self.rangePreview.Color = Color3.new(1, 1, 1)
		self.rangePreview.Parent = Workspace.Preview
		self.rangePreview.Shape = Enum.PartType.Cylinder
		self.rangePreview.Orientation = Vector3.new(0, 90, 90)
		-- Equipping tower tools (to place)
		player.CharacterAdded:Connect(function(char)
			local human = char:WaitForChild("Humanoid")
			char.ChildAdded:Connect(function(child)
				if not (child:IsA("Tool") and tTowerName(child.Name)) then
					return nil
				end
				self:startPlacingTower(child)
				local c
				c = char.AncestryChanged:Connect(function(_, p)
					if p ~= char then
						self:stopPlacingTower()
						c:Disconnect()
					end
				end)
			end)
			human.Died:Connect(function()
				return self:stopPlacingTower()
			end)
		end)
		-- Confirm placement
		UserInputService.InputBegan:Connect(function(input, gpe)
			if gpe then
				return nil
			end
			if input.UserInputType == Enum.UserInputType.MouseButton1 and self.isPlacing then
				self:confirmTowerPlacement()
			end
		end)
	end
	function TowerPlacementController:stopPlacingTower()
		if not self.isPlacing then
			return nil
		end
		self.isPlacing = false
		self.selectedTower("None")
		local _result = self.mouseStepped
		if _result ~= nil then
			_result:Disconnect()
		end
		self.rangePreview.Parent = Workspace.Preview
		self.rangePreview.Transparency = 1
		local _result_1 = self.previewModel
		if _result_1 ~= nil then
			_result_1:Destroy()
		end
	end
	function TowerPlacementController:startPlacingTower(tool)
		local tower = tool.Name
		if self.isPlacing then
			self:stopPlacingTower()
		end
		if tower == "None" then
			return nil
		end
		self.selectedTower(tower)
		self.isPlacing = true
		local preview = towerFolder[tower]:Clone()
		self.previewModel = preview
		preview.Parent = Workspace.Preview
		local _exp = preview:GetDescendants()
		-- ▼ ReadonlyArray.filter ▼
		local _newValue = {}
		local _callback = function(i)
			return i:IsA("BasePart")
		end
		local _length = 0
		for _k, _v in _exp do
			if _callback(_v, _k - 1, _exp) == true then
				_length += 1
				_newValue[_length] = _v
			end
		end
		-- ▲ ReadonlyArray.filter ▲
		for _k, _v in _newValue do
			makePartPreview(_v, _k - 1, _newValue)
		end
		local previewHitbox = preview.hitbox
		previewHitbox.Transparency = 0.9
		local range = TowerConfig[tower].range
		self.rangePreview:PivotTo(previewHitbox.CFrame)
		self.rangePreview.Size = Vector3.new(0.1, range * 2, range * 2)
		self.rangePreview.Transparency = 0.9
		self.rangePreview.Parent = preview
		self.mouseStepped = RunService.RenderStepped:Connect(function(dt)
			local pos = self:mouseToTowerPos(tower)
			if pos then
				if self:canPlace() then
					previewHitbox.Color = Color3.new(0, 1, 0)
				else
					previewHitbox.Color = Color3.new(1, 0, 0)
				end
				preview:MoveTo(pos)
			end
		end)
		tool.AncestryChanged:Connect(function(parent)
			if parent ~= player.Character then
				self:stopPlacingTower()
			end
		end)
	end
	function TowerPlacementController:canPlace()
		local mousePos = self:mouseToTowerPos(self.selectedTower())
		return mousePos ~= nil and self:posNotOnTrackOrTower(mousePos) and self.isPlacing
	end
	function TowerPlacementController:posNotOnTrackOrTower(pos)
		return self:posNotOnTower(pos) and self:posNotOnTrack(pos)
	end
	function TowerPlacementController:posNotOnTrack(pos)
		local path = self.trackController:getTrack().path:GetChildren()
		local tower = self.selectedTower()
		local radius = towerFolder[tower].hitbox.Size.Y / 2
		for _, part in path do
			local halfSizeX = part.Size.X / 2
			local halfSizeZ = part.Size.Z / 2
			local minX = part.Position.X - halfSizeX
			local maxX = part.Position.X + halfSizeX
			local minZ = part.Position.Z - halfSizeZ
			local maxZ = part.Position.Z + halfSizeZ
			local closestX = math.clamp(pos.X, minX, maxX)
			local closestZ = math.clamp(pos.Z, minZ, maxZ)
			local dx = pos.X - closestX
			local dz = pos.Z - closestZ
			if dx * dx + dz * dz < radius * radius then
				return false
			end
		end
		return true
	end
	function TowerPlacementController:posNotOnTower(pos)
		local tower = self.selectedTower()
		local radius = towerFolder[tower].hitbox.Size.Y / 2
		local _exp = Workspace.Towers:GetChildren()
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#_exp)
		local _callback = function(t)
			return t:FindFirstChild("hitbox")
		end
		for _k, _v in _exp do
			_newValue[_k] = _callback(_v, _k - 1, _exp)
		end
		-- ▲ ReadonlyArray.map ▲
		-- ▼ ReadonlyArray.filter ▼
		local _newValue_1 = {}
		local _callback_1 = function(t)
			return t:IsA("BasePart")
		end
		local _length = 0
		for _k, _v in _newValue do
			if _callback_1(_v, _k - 1, _newValue) == true then
				_length += 1
				_newValue_1[_length] = _v
			end
		end
		-- ▲ ReadonlyArray.filter ▲
		local towerHitboxes = _newValue_1
		local px = pos.X
		local pz = pos.Z
		for _, hitbox in towerHitboxes do
			-- defensive: ensure we have a valid BasePart
			if not hitbox or not hitbox:IsA("BasePart") then
				continue
			end
			local dx = px - hitbox.Position.X
			local dz = pz - hitbox.Position.Z
			if dx * dx + dz * dz < radius * radius then
				return false
			end
		end
		return true
	end
	function TowerPlacementController:confirmTowerPlacement()
		local selectedTower = self.selectedTower()
		local _isPlacing = self.isPlacing
		local _arg1 = `{"[src/client/controllers/TowerPlacementController.ts:218]"} {"this.isPlacing"}: Assertion failed!`
		assert(_isPlacing, _arg1)
		local _arg0 = selectedTower ~= "None"
		local _arg1_1 = `{"[src/client/controllers/TowerPlacementController.ts:219]"} {'selectedTower !== \"None\"'}: Assertion failed!`
		assert(_arg0, _arg1_1)
		local placementPos = self:mouseToTowerPos(selectedTower)
		local _arg1_2 = `{"[src/client/controllers/TowerPlacementController.ts:221]"} {"placementPos"}: {`this.mouseToTowerPos({self.selectedTower}) returned undefined`}`
		assert(placementPos, _arg1_2)
		local _clone = self.previewModel
		if _clone ~= nil then
			_clone = _clone:Clone()
		end
		local clone = _clone
		Functions.requestPlaceTower:invoke(placementPos, selectedTower):andThen(function(wasPlaced)
			if wasPlaced then
				local _result = clone
				if _result ~= nil then
					_result:Destroy()
				end
			else
				-- Failed, make clone red then destroy or seomthing
				local _result = clone
				if _result ~= nil then
					_result:Destroy()
				end
			end
		end)
	end
	function TowerPlacementController:mouseToTowerPos(tower)
		local _binding = UserInputService:GetMouseLocation()
		local X = _binding.X
		local Y = _binding.Y
		local _binding_1 = camera:ViewportPointToRay(X, Y)
		local Origin = _binding_1.Origin
		local Direction = _binding_1.Direction
		local rayParams = RaycastParams.new()
		rayParams.FilterType = Enum.RaycastFilterType.Exclude
		rayParams.FilterDescendantsInstances = { Workspace.Preview, Workspace.Live, Workspace.Towers }
		local rayResult = Workspace:Raycast(Origin, Direction * 1000, rayParams)
		if rayResult then
			local _binding_2 = rayResult.Position
			local X = _binding_2.X
			local Z = _binding_2.Z
			local worldSize = towerFolder[tower]:GetExtentsSize()
			local Y = rayResult.Position.Y + worldSize.Y / 2
			return Vector3.new(X, Y, Z)
		end
	end
	do
		-- (Flamework) TowerPlacementController metadata
		Reflect.defineMetadata(TowerPlacementController, "identifier", "client/controllers/TowerPlacementController@TowerPlacementController")
		Reflect.defineMetadata(TowerPlacementController, "flamework:parameters", { "client/controllers/TrackController@TrackController", "client/controllers/ClientStateProvider@ClientStateProvider" })
		Reflect.defineMetadata(TowerPlacementController, "flamework:implements", { "$:flamework@OnStart" })
	end
end
-- (Flamework) TowerPlacementController decorators
Reflect.decorate(TowerPlacementController, "$:flamework@Controller", Controller, { {} })
function makePartPreview(part)
	if part.Name == "hitbox" then
		return nil
	end
	part.Transparency = 0.5
	part.CanCollide = false
	part.CanQuery = false
end
return {
	TowerPlacementController = TowerPlacementController,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="35">
            <Properties>
              <string name="Name">TowerRenderer</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Reflect = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Reflect
local Controller = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Controller
local Events = TS.import(script, script.Parent.Parent, "networking").Events
local Tower_C = TS.import(script, script.Parent.Parent, "classes", "Tower_C").Tower_C
--[[
	*
	 * Syncs tower's data and renders tower instances
	 
]]
local TowerRenderer
do
	TowerRenderer = setmetatable({}, {
		__tostring = function()
			return "TowerRenderer"
		end,
	})
	TowerRenderer.__index = TowerRenderer
	function TowerRenderer.new(...)
		local self = setmetatable({}, TowerRenderer)
		return self:constructor(...) or self
	end
	function TowerRenderer:constructor(enemyController, stateProvider)
		self.enemyController = enemyController
		self.stateProvider = stateProvider
		self.towers = {}
	end
	function TowerRenderer:onStart()
		Events.towerPlaced:connect(function(i, p, t, o)
			return self:onTowerPlaced(i, p, t, o)
		end)
		Events.towerDeleted:connect(function(i)
			return self:onTowerDeleted(i)
		end)
		Events.towerAttackedEnemy:connect(function(t, e)
			return self:onTowerAttackedEnemy(t, e)
		end)
		Events.setTowerTargetMode:connect(function(i, t)
			return self:onTowerTargetModeChanged(i, t)
		end)
	end
	function TowerRenderer:onTowerTargetModeChanged(id, mode)
		local _towers = self.towers
		local _id = id
		local tower = _towers[_id]
		tower.targetMode = mode
	end
	function TowerRenderer:onTowerPlaced(id, pos, tower, owner)
		local newTower = Tower_C.new(id, pos, tower, self.enemyController, owner)
		local _towers = self.towers
		local _id = id
		_towers[_id] = newTower
	end
	function TowerRenderer:onTowerDeleted(id)
		local _towers = self.towers
		local _id = id
		_towers[_id]:destroy()
		local _towers_1 = self.towers
		local _id_1 = id
		_towers_1[_id_1] = nil
	end
	function TowerRenderer:onTowerAttackedEnemy(towerId, enemyId)
		local _towers = self.towers
		local _towerId = towerId
		local tower = _towers[_towerId]
		if tower then
			tower.damageDealt += tower.info.damage
		end
	end
	do
		-- (Flamework) TowerRenderer metadata
		Reflect.defineMetadata(TowerRenderer, "identifier", "client/controllers/TowerRenderer@TowerRenderer")
		Reflect.defineMetadata(TowerRenderer, "flamework:parameters", { "client/controllers/EnemyController@EnemyController", "client/controllers/ClientStateProvider@ClientStateProvider" })
		Reflect.defineMetadata(TowerRenderer, "flamework:implements", { "$:flamework@OnStart" })
	end
end
-- (Flamework) TowerRenderer decorators
Reflect.decorate(TowerRenderer, "$:flamework@Controller", Controller, { {} })
return {
	TowerRenderer = TowerRenderer,
}
]]></string>
            </Properties>
          </Item>
          <Item class="ModuleScript" referent="36">
            <Properties>
              <string name="Name">TrackController</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Reflect = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Reflect
local Controller = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Controller
local CollectionService = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "services").CollectionService
local TAG_TRACK = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "constants").TAG_TRACK
local TrackController
do
	TrackController = setmetatable({}, {
		__tostring = function()
			return "TrackController"
		end,
	})
	TrackController.__index = TrackController
	function TrackController.new(...)
		local self = setmetatable({}, TrackController)
		return self:constructor(...) or self
	end
	function TrackController:constructor()
		self.waypoints = {}
		self.trackLength = -1
		self.trackInstance = nil
	end
	function TrackController:onInit()
		--[[
			*
			         * Change to wait for all waypoints to load in
			         
		]]
		task.wait(1)
	end
	function TrackController:onStart()
		local trackInstance = CollectionService:GetTagged(TAG_TRACK)[1]
		local _exp = trackInstance.waypoints:GetChildren()
		table.sort(_exp, function(a, b)
			return tonumber(a.Name) < tonumber(b.Name)
		end)
		-- ▼ ReadonlyArray.map ▼
		local _newValue = table.create(#_exp)
		local _callback = function(i)
			return i.Position
		end
		for _k, _v in _exp do
			_newValue[_k] = _callback(_v, _k - 1, _exp)
		end
		-- ▲ ReadonlyArray.map ▲
		self.waypoints = _newValue
		local total = 0
		for i = 0, #self.waypoints - 2 do
			local _exp_1 = self.waypoints[i + 2]
			local _arg0 = self.waypoints[i + 1]
			total += (_exp_1 - _arg0).Magnitude
		end
		self.trackLength = total
		self.trackInstance = trackInstance
	end
	function TrackController:getWaypoints()
		return self.waypoints
	end
	function TrackController:getTrack()
		return self.trackInstance
	end
	function TrackController:getTrackLength()
		return self.trackLength
	end
	function TrackController:getPositionOnTrack(speed, t)
		local d = speed * t
		local distAccum = 0
		for i = 0, #self.waypoints - 2 do
			local a = self.waypoints[i + 1]
			local b = self.waypoints[i + 2]
			local L = (b - a).Magnitude
			if d <= distAccum + L then
				local segDist = d - distAccum
				local alpha = segDist / L
				return a:Lerp(b, alpha)
			end
			distAccum += L
		end
		-- Clamp to the last waypoint if we've passed the end
		return self.waypoints[#self.waypoints]
	end
	do
		-- (Flamework) TrackController metadata
		Reflect.defineMetadata(TrackController, "identifier", "client/controllers/TrackController@TrackController")
		Reflect.defineMetadata(TrackController, "flamework:implements", { "$:flamework@OnInit", "$:flamework@OnStart" })
	end
end
-- (Flamework) TrackController decorators
Reflect.decorate(TrackController, "$:flamework@Controller", Controller, { {} })
return {
	TrackController = TrackController,
}
]]></string>
            </Properties>
          </Item>
        </Item>
        <Item class="LocalScript" referent="37">
          <Properties>
            <string name="Name">main</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local Flamework = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out").Flamework
Flamework._addPaths({ { "StarterPlayer", "StarterPlayerScripts", "TS", "classes" } })
Flamework._addPaths({ { "StarterPlayer", "StarterPlayerScripts", "TS", "controllers" } })
Flamework._addPaths({ { "StarterPlayer", "StarterPlayerScripts", "TS", "components" } })
Flamework.ignite()
print("[src/client/main.client.ts:9]", "Flamework client ignited!")
]]></string>
          </Properties>
        </Item>
        <Item class="ModuleScript" referent="38">
          <Properties>
            <string name="Name">networking</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local t = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@flamework", "core", "out", "prelude").t
local _networking = TS.import(script, game:GetService("ReplicatedStorage"), "TS", "networking")
local GlobalEvents = _networking.GlobalEvents
local GlobalFunctions = _networking.GlobalFunctions
local Events = GlobalEvents:createClient({}, {
	incomingIds = { "setEquipBar", "updateEquipBar", "playerStateChanged", "enemySpawned", "enemyDeleted", "updateEnemyHealth", "syncEnemies", "towerPlaced", "towerDeleted", "setTowerTargetMode", "towerAttackedEnemy", "setUnlockedInventory", "addToUnlockedInventory", "removeFromUnlockedInventory" },
	incoming = {
		setEquipBar = { { t.array(t.literalList({ "None", "Barbarian", "Archer", "Cannon", "Sharpshooter" })) }, nil },
		updateEquipBar = { { t.number, t.literalList({ "None", "Barbarian", "Archer", "Cannon", "Sharpshooter" }) }, nil },
		playerStateChanged = { { t.string, t.union(t.any, t.none), t.union(t.any, t.none) }, nil },
		enemySpawned = { { t.number, t.literalList({ "Skeleton", "Armored_Skeleton", "Goblin" }) }, nil },
		enemyDeleted = { { t.number }, nil },
		updateEnemyHealth = { { t.number, t.number }, nil },
		syncEnemies = { { t.array(t.interface({
			id = t.number,
			pos = t.Vector3,
			elapsed = t.number,
			health = t.number,
		})) }, nil },
		towerPlaced = { { t.number, t.Vector3, t.literalList({ "None", "Barbarian", "Archer", "Cannon", "Sharpshooter" }), t.instanceIsA("Player") }, nil },
		towerDeleted = { { t.number }, nil },
		setTowerTargetMode = { { t.number, t.literalList({ "First", "Last", "Closest" }) }, nil },
		towerAttackedEnemy = { { t.number, t.number }, nil },
		setUnlockedInventory = { { t.array(t.literalList({ "None", "Barbarian", "Archer", "Cannon", "Sharpshooter" })) }, nil },
		addToUnlockedInventory = { { t.literalList({ "None", "Barbarian", "Archer", "Cannon", "Sharpshooter" }) }, nil },
		removeFromUnlockedInventory = { { t.literalList({ "None", "Barbarian", "Archer", "Cannon", "Sharpshooter" }) }, nil },
	},
	incomingUnreliable = {},
	outgoingIds = { "setEquipBar", "updateEquipBar" },
	outgoingUnreliable = {},
	namespaceIds = {},
	namespaces = {},
})
local Functions = GlobalFunctions:createClient({}, {
	incomingIds = {},
	incoming = {},
	outgoingIds = { "requestPlaceTower", "requestStartGame" },
	outgoing = {
		requestPlaceTower = t.boolean,
		requestStartGame = t.boolean,
	},
	namespaceIds = {},
	namespaces = {},
})
return {
	Events = Events,
	Functions = Functions,
}
]]></string>
          </Properties>
        </Item>
        <Item class="LocalScript" referent="39">
          <Properties>
            <string name="Name">setCore</string>
            <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
]]></string>
          </Properties>
        </Item>
        <Item class="Folder" referent="40">
          <Properties>
            <string name="Name">ui</string>
          </Properties>
          <Item class="ModuleScript" referent="41">
            <Properties>
              <string name="Name">Tooltip</string>
              <string name="Source"><![CDATA[-- Compiled with roblox-ts v3.0.0
local TS = require(game:GetService("ReplicatedStorage"):WaitForChild("rbxts_include"):WaitForChild("RuntimeLib"))
local React = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "react")
local useAtom = TS.import(script, game:GetService("ReplicatedStorage"), "rbxts_include", "node_modules", "@rbxts", "react-charm").useAtom
local function TooltipUI(_param)
	local hoveredTower = _param.hoveredTower
	local visibleAtom = _param.visibleAtom
	local mousePosAtom = _param.mousePosAtom
	local ownerAtom = _param.ownerAtom
	local visible = useAtom(visibleAtom)
	local tower = useAtom(hoveredTower)
	local _binding = useAtom(mousePosAtom)
	local X = _binding.X
	local Y = _binding.Y
	local owner = useAtom(ownerAtom)
	local _attributes = {
		key = "TooltipText",
		Size = UDim2.fromScale(1, 1),
		BackgroundTransparency = 1,
	}
	local _condition = owner
	if _condition == nil then
		_condition = "N/A"
	end
	_attributes.Text = `{tower}\nOwned by: {_condition}`
	_attributes.TextColor3 = Color3.new(0.61, 0.32, 0.32)
	_attributes.TextStrokeColor3 = Color3.new(0, 0, 0)
	_attributes.TextStrokeTransparency = 0
	_attributes.TextScaled = true
	_attributes.ZIndex = 11
	_attributes.RichText = false
	return React.createElement("screengui", {
		ResetOnSpawn = false,
		key = "ToolTipGUI",
		IgnoreGuiInset = true,
		Enabled = visible,
	}, React.createElement("frame", {
		key = "TooltipContainer",
		AnchorPoint = Vector2.new(0, 0),
		Position = UDim2.fromOffset(X + 10, Y + 5),
		Size = UDim2.fromOffset(75, 40),
		BackgroundTransparency = 1,
		ZIndex = 10,
	}, React.createElement("textlabel", _attributes)))
end
return {
	TooltipUI = TooltipUI,
}
]]></string>
            </Properties>
          </Item>
        </Item>
      </Item>
    </Item>
  </Item>
</roblox>